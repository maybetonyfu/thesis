% Chapter 1

\chapter{Introduction}

\label{intro} 

\graphicspath{{Figures/Introduction}}

\section{From Types Comes Type Errors}

In the research of programming languages, \textbf{static typing} is a widely adopted compile-time program validation method where types of expressions are checked against their usage at compile time. Statically typed languages range from the earliest programming languages \cite{Backus1978-xt}, to the most widely used languages in all platforms \cite{Ritchie1978-pa}, and the renowned academic languages \cite{Hudak2007-kn}. In practice, statically type programming languages offer many advantages: It allows early error detection, enhances code readability, and promotes maintainability, especially in large collaborative projects. The explicit type information often improves tooling and IDE (interactive development environment) support. Additionally, static typing enhances the library documentation by providing clear contracts between library authors and uses.

\textbf{Functional language} is a programming language category where functional programming principles are enforced. These include immutable values and referential transparency. Like statically typing, functional language also helps avoid certain undesired behaviors of programs, such as misaligned pointers and race conditions, by removing or carefully separating the effectful computation from the pure one. In addition, functional programming promotes the idea of using functions as the fundamental building blocks of programming and developing abstractions by composing functions. For these reasons, functional programming languages are often taught to beginners. Lastly, functional language's strict immutability provides distinct advantages in concurrency and parallelism.

Combining the two disciplines, \textbf{statically typed functional languages} employ both static typing and the principles of functional programming. These languages, including Haskell and ML, often provide the strongest level of programming safety. It is often advertised that programs in these languages will be error-free if the source code passes the compiling stage, indicating that compilers are able to weed out many classes of errors. With these safety properties, statically typed functional languages are often used as proof assistance and formal verifications where rigorous type-checking is paramount. Despite the safety benefits, these languages failed to gain significant popularity in mainstream programming. This lack of popularity is often attributed to higher barriers to entry, unfamiliarity, and unforgiving type errors.

One major issue stemmed from the promises of statically typed languages is the complexity involved in the systems and tools that safeguard the type-checking process. Ordinarily, this complexity is hidden away from the users. However, most compiler tools failed in usability when they encounter incorrectly typed programs. Many factors contribute to this lack of usability. First, some argues that the expressiveness and power of type systems often come at the cost of usability~\cite{Hage2020-hg}.  Programmers often find type errors hard to read and understand when high-level abstractions are in play such as monads, type classes, and polymorphic types. Second, type errors often use unfamiliar languages with liberal uses of jargon. Last, the type error locations and explanations provided by traditional compiler tools are often misleading or wrong. All these factors make debugging type errors notoriously difficult.

\section{The Open Challenges Of Type Errors}

Type errors can be notoriously difficult to understand and use, particularly for newcomers to programming or when using a language that is particularly strict about types. Type errors are often believed to be a major contributor to static typing's reputation of high barrier to entry. I believe it is important to understand the root of challenges in using type error in order to address them. To achieve that, I believe it is useful to put type errors in proper context, more specifically, comparing them with other classes of programming errors (parsing errors, runtime errors). 

\subsection{Types Are As Complex As Runtime Values}

Unlike expressions (values and variables) of a program, Types are computed at compile time. But similar to evaluation semantics, the type checking computations can be complex. In fact, many programming languages type checking are shown to be non-terminating and Turing complete~\cite{Wells1999-ob}. This raises the challenge of explaining such complex computing process when programmers' attentions are needed to correct ill-typed programs. Type checking cannot be inspected using conventional tools. Inserting print statement inside type annotation is not possible. 


\subsection{Clues For Type Checking Are Implicit}
Understanding type assignments of the program become more challenging when the programming language uses type inference.  Type inference \cite{Damas1982-sc},  also known as implicit typing,  is a technique that allow programmers to omit the ritual of writing type annotations all together and the type checker will infer the most general types (principal types) for each expression. Even for languages that don't employ implicit typing, some typing rules are hidden from programmers.
For example the \texttt{if} expression in many programming languages. The semantics is very clear, but the typing rules are hidden.

\begin{figure}[hbt]
  \includegraphics[width=\linewidth]{IfRules.png}
  \caption{
   The evaluation rules and typing rules of if expression in a typical programming language.
    }
\end{figure}


\subsection{Lack of tool support}
Lastly, few tools are dedicated on supporting type errors. Runtime programming errors have been studied extensively as a research subject and numerous industry tools are focus on understanding and solve runtime errors(GDB, breakpoints.) However, in comparison, tool support type error  remain the same depth and capability as they were many decades ago. Most the programming environments render type errors verbatim to the terminal.   


\begin{figure}[hbt]
  \includegraphics[width=\linewidth]{FreePascal.jpg}
  \caption{
    Run time debugging using break point in the Free Pascal interactive development environment in 1997
    }
\end{figure}

\begin{figure}[hbt]
  \includegraphics[width=\linewidth]{DrScheme}
  \caption{
    Dr Scheme, an interactive development environment for the Scheme language, highlighting a runtime error
    }
\end{figure}

My research is motivated by the inherent difficulties in debugging type errors and the dormant development of improving type errors by making use of the modern graphical capabilities and HCI techniques.

\section{Research Aim}

\subsection{Aim 1. Develop a Comprehensive Understanding of the Knowledge Required by Programmers to Understand and Resolve Type Errors.}

To date, there is no unified representation of type errors. But most contemporary compiler tools represent type error as the combination of three objects: a location where the failed type checking failed, an expected input, and the actually encountered input.

\subsubsection{Objective 1.1 To Identify and Accurately Report Multiple Locations Contributing to Type Errors.}

Traditional tools are limited to reporting a single location for the type error. This has been addressed by many researchers as an unhelpful limitation. Programmers are often unable to find resolution at the reported location and are forced to expand their search without guidance. We want to improve this by reporting accurate locations that are relevant to the type error.

\subsubsection{Objective 1.2 To Communicate that there may be more than one explanation for a type error}

Erroneous programs can often be explained in multiple ways. When two pieces of evidence contradict each other, traditional tools choose the first one they encounter as the truth and the second one the culprit. When a contradiction consists of more than two pieces of evidence, traditional tools will generally ignore everything after the infeasibility is encountered. To improve this, first, we want to preserve the multiple explanations of type errors without picking sides. Second, we want to take into account all evidence.

\subsubsection{Objective 1.3 To Communicate That There May Be More Than One Cause Of A Type Error}

Type error does not end with a location in the source code. Programmers can still struggle to resolve a type error even after reaching the exact location of the culprits, failing to understand the logical explanation of the type error. Internally type error can be caused by mismatched types, unfulfilled type class constraints, or trying to construct infinite types. Externally, type error can be caused by typos, outdated type annotation, incomplete implementation, too few or too many arguments in a function application, etc.. Helping programmers find the cause or provide an accurate inference of what is the cause of the type error.

\subsection{Aim 2. Support Resolution Of Type Errors Through Modern Programming Environments.}

To integrate rich type error data into a modern, visual programming environment and workflow that allows people to work more efficiently with strongly typed languages.


When humans are put in the middle, more information does not equal better comprehension. With enriched data representation, we want to deliver type errors to better support programmersâ€™ comprehension and the chance for a successful resolution.

\subsubsection{Objective 2.1 Communicate the key concepts of type errors effectively using modern programming tools}

The concepts of type errors are traditionally displayed as text. These concepts include error locations, alternative explanations, causes and intermediate type signatures. We explore more intuitive techniques and media to communicate these concepts to better facilitate comprehension.

\subsubsection{Objective 2.2 Use Interactive Tools for Investigating and Resolving Type Errors.}

To avoid presenting overwhelming information, we explore different techniques of interactively exploring the type errors. These techniques include dividing the type error into small chunks that follow a linear line of reasoning, or bisecting the error one step at a time into smaller concepts.


\section{Contributions}


\subsection{A categorization of type errors based on the structure of the evidence of a type error}

A \textbf{multi-step type error} is a type error that involve multiple inference steps between the two endpoints. An important challenge with multi-step type error is to convey the logical relation of every location while presenting the infeasibility. 

A \textbf{multi-witness type error} is a type error that involve multiple endpoints supporting the same typing possibility. With multi-witness type error, it is harder to focus on the logical relation of every location as the complexity grows exponentially as the number of witness increases. Rather, it is more helpful to identify the two typing possibilities and the endpoint locations that supporting them.

A \textbf{multi-party type error} is a type error that involve more than two typing possibility. The multi-party type error is thought to be less intuitive and harder to comprehend. The most prominent task is to separate the type error into simpler type errors. 


With this classification, I contributed two systems -- Chameleon and Goanna -- to address the challenges of type error debugging in different error categories.

\subsection{Explaining Multi-Step Type Errors Through Chain-Of-Thought Visualization}

\subsubsection{Technical Contribution - Chameleon}
We contribute Chameleon, an interactive Haskell type error debugging tool. Internally, Chameleon computes all relevant locations that contribute to the type of error. Via a set of iteratively designed interface, Chameleon preserves the two alternatives of the type error and the supporting evidence for each.

\subsubsection{An evaluation on how programmers use type error slicing and chain of thought visualization to understand type errors}
We  contributed a series of studies of the effects of debugging with visual representation of types and interactively explored type errors. We show that there is a difference between using traditional tools and enhanced type error debugging tools like Chameleon. And we show that this difference is more significant when debugging complex type errors.

\subsection{Iterate potential causes of multi-witness and multi-party errors}

\subsubsection{Technical Contribution -- Goanna}

We contribute Goanna, a Haskell type error debugging tool. 

Like Chameleon, Goanna iterates relevant locations that contribute to the type error and presents alternatives to the type error. 

Different from Chameleon, Goanna will exhaust all possible alternative explanations of the type error. Also, Goanna presents a type error by dividing it into a list of potential causes and their respective fixes. With Goanna, Haskell programmers can resolve type errors by exploring a list of potential error root causes. These causes are ordered using our heuristics so that the more likely causes are on top. We show that via our empirical evaluation that Goanna outperforms existing Haskell compilers when explaining the type error, with the slight disadvantage of an increased computation time.

\subsubsection{An evaluation on accuracy, conciseness and performance of MCS-based type debugging and our heuristics}

We evaluated Goanna's effectiveness using 86 diverse Haskell programs from online discourse, demonstrating its ability to accurately identify and resolve type errors. Additionally, we present a collection of techniques and heuristics to enhance Goanna's suggestion-based error diagnosis and show their effectiveness from our evaluation.


\subsection{Visualizing Types}

\subsubsection{Technical Contribution -- GeckoGraph}

In addition to the two systems, I also contribute GeckoGraph, a graphic notation for Haskell types. GeckoGraph describes the same information as a type signature does, but uses colors, shapes, and symbols to make certain structures easy to identify at a glance. GeckoGraph is designed to use visual elements to improve the understanding of type-level concepts. This includes type classes, parametric type variables, and high-rank types. When used to compare two types, GeckoGraph helps clarify differences visually. It makes errors like too few or too many arguments in applications, unmet type class constraints obvious.

\subsubsection{An evaluation on how programmers use graphic type notation}

We conducted a large-scale study on the effectiveness of using GeckoGraph to perform a series of Haskell tasks. We concluded that with GeckoGraph, programmers are able to succeed in harder tasks.

% \section{Research Method}

% \subsection{Human-centered programming language studies}

% One important decision that shape a lot of my work is employing human-centered research methods with our novel programming language systems. The adopting of human-centered methods happens at every stage of the projects: prototyping, development and evaluation. Although the using of these methods are not new at all, but they certainly are not the most polular choices in programming language studies.

% The motive of such decision is that it is impossible to understand what are the good qualities of type errors without observing how human use type errors to gain understanding. 


% The downside of study programming language is iterative design is very hard. programming tasks involves complex inputs and outputs, and it is very hard to study an incomplete system without a fully working systems. For instance, if we are to study the effect of type errors, it is most effective to have a system that can recognize type-correct program from ill-typed one. It is hard to evaluate with a mock-up or wizard of oz style fake outputs to study users' interaction.  To address this limitations, we have a few ideas implemented in our research:

% A minimal but practical set of language 
% Design for human from start



\section{Thesis outline}

The thesis can be divided into two parts. The first part (Chapters 1, 2 and 3) survey the vivid panorama of type systems and programming languages. The purpose of these chapters is: 1. to situate the work I will illustrate in later chapters, 2 to introduce the proper definitions and terminilogies I use in this thesis.  The second part (Chapters 4, 5, 6, and 7) delve into three individual pieces of work, each targeting a specific problem in type error debugging.


% \subsection{Chapter 2}

% Chapter 2 introduce the development of two programming features: functional programming and static typing. We started by introducing the evolutions functional programming and static typing. We discuss their counterparts and the arguments against them. We then discuss the important milestones in improving compiler type error messgaes. We discuss the emerging demmand of these tools of programming robust code, as the way we program altered by the seismic impact of large language models.  


\subsection{Chapter 2}
We provide some technial background in Chapter 3. This include the tradiional methods of Haskell type checking and constraint based type inference. Follow this thread, we continue to discuss the tools and techniques in constraint satisfiability analyasis that we use to improve type error reprotiong in later chapters. Last, we give the categorization of type errors and their examples. 

\subsection{Chapter 3}
This chapter introduce the work related to our implementation of Chameleon and our study on its effect on debugging type error. This chapter starts by an introduction of our motivation, succinctly summarised in three characteristics of bad type error messages. We then introduce Chamaleon by imagining oursevles as a hypothetical programmer combating with Haskell type errors, luckily with the help of Chameleon. We go on to introduce the system design and iterative prototyping methods used to develop Chameleon. Lastly, we our series of experiments on Chameleon's effect on sovling type errors comparing to traditional compiler tools. 


\subsection{Chapter 4}

The work we discuss in Chapter 5 is about Goanna. Goanna is a Haskell type error debugger we developed. In this chapter, we first report some common limitations of traditional compiler error messages. We then go on to showcase how Goanna fix type errors is able to address these limitations, in a few examples of realistic type errors.  Next, we discuss the implementation of Goanna and our heuritics for ranking potential causes and identifying unhelpful suggestions. Last, we show our empirical study of the accuracy, conciseness and performance of Goanna using a colllection of real world Haskll type errors. 

\subsection{Chapter 5}

In this chapter, we discuss our work on visualizing type annotations. In this, we showed our work in GeckoGraph and our empirical study on its effect. We start by present some usability challenges in using polymorphic types. We then descibe the design goal of GeckoGraph and how it can be constructed from a textual type annotation using a few construction rules. We then show our large-scale study on the effect of using visual type annoations in programming and solving type errors. 


\subsection{Chapter 6}

The last chapter, we recount our contribitions with more remarks on their contexts. We discuss a few directions of future work. This include the direction in future tool development, as well as future research opportunities. Lastly, in the closing words, we return to the map field of programming language and vast uncharted area that is the future of programming. 