% Chapter 1

\chapter{Introduction}

\label{chap:introduction} 

\graphicspath{{Figures/Introduction}}

Programming languages are the media through which we communicate our ideas with machines, be it mathematical formulae or video games. Like human language, programming languages consist of words, grammar, and meaning. Unlike conversing with humans, machines tolerate very little ambiguity and are not skillful at navigating confusion. Furthermore, sometimes inconsistencies glossed over by humans can be indicative of bigger oversights; for example, mismatched expression types can be indicative of an ill-defined mapping. 

We will delve into two critical aspects of programming language design: their typing disciplines and the paradigms to which they subscribe. Through this, we hope to illustrate a common trade-off in programming: that the more certainty a programmer attains through programming language rules and checks that their program will run correctly, the more difficulty the programmer has in conforming to those rules and checks. Further, when these rules and checks are violated, we meet the anguish of the machine in arcane jargon, sometimes all in uppercase letters. My interventions -- most notably, Chameleon (Chapter \ref{chap:chameleon}), Goanna (Chapter~\ref{chap:goanna}), and GeckoGraph (Chapter~\ref{chap:gecko-graph}) -- aim to transform the traditional, often terse, error feedback into a dynamic and clear diagnostic system enhanced by interactive user interfaces. Our goals are to provide programmers with clarity, intuition, and confidence. In this:

\begin{itemize}
  \item \textbf{Clarity}: We aim to provide succinct and accurate explanations of errors, cutting through unfamiliar terminologies, awkwardly phrased sentences, and excessive amounts of unhelpful information that often obscure the underlying issues.
  \item \textbf{Intuitiveness}: Our systems are designed with user-friendly interfaces that are easy to learn, comprehend, and use, ensuring that programmers of all skill levels can efficiently navigate and rectify errors.
  \item \textbf{Confidence}: Building on solid foundations in programming language theory and constraint satisfiability research, our tools maintain the rigorous program safety features expected from traditional compilers, while enhancing the user experience.
\end{itemize}

Through these innovative systems, we strive to demystify error messages and equip programmers with better tools to write correct programs. 

\section{From types to program correctness}

In programming language theory and practice, type systems are a widely adopted program validation method where types of expressions are checked against their usage. In the early history of programming, types were used to inform the compiler of how much memory needs to be allocated for each value. Now, type systems are much more powerful; programmers can express complex ideas, like communication protocols and concurrency characteristics. Conventionally, the discipline of typing is identified by the existence of a compile-time checking stage. A programming language is said to be statically typed if checks are performed before a program is executed.  On the other hand, dynamically-typed languages (colloquially called dynamic languages) will not complain about type mismatch prior to the program being run, and they do not facilitate describing the types (Fig.\ \ref{fig:typed-vs-untyped}). In dynamic languages, expressions like \texttt{4 + "2"} may produce unintended consequences, for example, a runtime error causing the program to terminate early, or some languages may try to perform unexpected coercion of data types, producing the answer ``42'' (i.e.\ string concatenation instead of numeric addition). 

Statically-typed languages have a long history and are extremely popular, with examples among both the earliest of programming languages (such as FORTRAN and ALGOL, \cite{Backus1978-xt}) and the most widely-used languages across all platforms  (such as C---\cite{Ritchie1978-pa}---and its derivatives, including Java and C\#). Static typing is also a core feature of the most advanced and renowned academic languages (such as ML and Haskell---\cite{Hudak2007-kn}---as well as their derivatives, such as OCaML and Agda, respectively). In practice, statically typed programming languages offer many advantages. Type declarations and annotations add important contextual information about the expected use of variables and expressions. This additional context allows early error detection but also enhances code readability and promotes maintainability (\cite{Kleinschmager2012-bg}), especially in large collaborative projects. The explicit encapsulation of type information in code also creates opportunities for improved tooling through intelligent compiler services and IDE (interactive development environment) support. Additionally, static typing enhances code documentation by providing clear contracts between library authors and users and, more generally, enhancing code reusability (\cite{Endrikat2014-uz}).


In comparison, dynamic typing has its own benefits and has an equal, if not stronger, influence in the computing world. In dynamically-typed languages, a variable can hold different types of values because the type is checked during runtime. This provides more flexibility than static typing since a function can be used to process different types of input values without any special semantics. However, this flexibility also carries risk, such as the example expression \texttt{4 + "2"}, above, where continuing execution with an incorrect value could have negative outcomes for code running in a production environment.
%: expressions like \texttt{4 + "2"} will not be identified before executing the program; some languages try to perform unexpected coercion of data types to avoid errors, producing the answer ``42''. 

Languages within the Lisp family, such as Common Lisp and Scheme, epitomize the advantages of dynamic typing. In these languages, a prevalent design pattern involves functions accepting dynamically typed inputs that can be atoms, lists, or s-expressions. The function's behavior changes based on the runtime inspection of these inputs. Additionally, dynamic languages often have a lower learning curve. Programmers are not burdened with declaring and adhering to strict type constraints, allowing them to focus more on immediate computational tasks. In the modern computing landscape, the popularity of dynamic languages like JavaScript and Python can be attributed to their flexibility and ease of use, which significantly lowers the barrier to entry for new programmers \cite{Chatley2019-uq}.


It comes as no surprise that large amounts of work were dedicated to deciding which one of the two typing disciplines is superior. Over the years, numerous studies have attempted to compare these typing disciplines and their impact on various aspects of software development, including software quality (\cite{Ray2017-gq, Gao2017-xn}), maintainability (\cite{Kleinschmager2012-bg}), error resolution (\cite{Prechelt1998-pd}), development speed for new features (\cite{Prechelt2000-bf, Mayer2012-qc}), and comprehensibility (\cite{Endrikat2014-uz}). Unfortunately, these studies have not led to a consensus, as the impacts of the typing disciplines can be overshadowed by more dominating factors such as the style of the programming languages used and the skill levels of the programmers involved.

Despite the lack of universal agreement, a general consensus suggests that dynamically typed languages are often more suited for beginners and rapid prototyping, thanks to their flexibility and ease of use. Conversely, statically typed languages are typically favored in larger projects or environments where ongoing feature development and team collaboration are prevalent. This preference is due to the inherent type safety features, which help manage complexity and reduce certain errors as projects scale \cite{Chatley2019-uq}.


\begin{figure}[hbt]
  \includegraphics[width=\linewidth]{TypedVsUntyped.pdf}
  \caption{
    \label{fig:typed-vs-untyped}
    Comparison of the same program dynamically typed in Python (Top) and with mypyâ€”a static typing tool for Python (Bottom).  The dynamic-typing rules of the Python interpreter apply, at run-time, the string concatenating version of the `+' operator -- regardless of the programmer's intention.  By contrast, mypy static-typing checks the type of the values passed to the {\tt plus} function against the intention declared by the programmer through the type annotations on the function parameters (both {\tt int}) and its return type (also {\tt int}).  The type check will fail until the programmer amends the function call with numeric arguments or otherwise explicitly converts the values from {\tt str} to {\tt int}.
    }
\end{figure}



\section{Functional Programming}

Alongside static typing, \textbf{functional programming} represents another rigorous approach to software development, drawing inspiration from Alonzo Church's lambda calculus in the 1930s \cite{Church1985-bx}. Functional programming treats functions as fundamental building blocks, emphasizing the composition of functions to develop abstractions.

Pure functional programming languages, characterized by immutable values and referential transparency, promote mathematical rigor. Immutable values ensure that once a value is declared, it cannot be altered. Referential transparency guarantees that functions will always produce the same output for identical inputs, providing predictable and testable code.

 A specific subset of functional programming languages, known as `pure' functional programming languages, incorporates additional mathematical rigor through concepts such as immutable values and referential transparency. Immutable values are those that, once declared, cannot be altered. Referential transparency ensures that functions consistently produce the same output for the same input. These properties help mitigate undesirable programming behaviors similar to the way static typing does. For example, the absence of mutable pointers and shared memory in pure functional languages eliminates common concurrency issues like misaligned pointers and race conditions. Consequently, programs developed using these languages are more predictable and can be robustly tested and reasoned about. This significantly reduces the risks that external factors such as network fluctuations or time variations could unpredictably affect program behavior.

Functional programming is often advocated as an excellent choice for introductory programming courses due to its emphasis on mathematical reasoning and strict programming discipline. This discipline includes the clear separation of data from its transformations, fostering a structured approach to problem-solving.


\begin{figure}[hbt]
  \includegraphics[width=\linewidth]{ImperativeFunctional}
  \caption{
    \label{fig:imperative-vs-functional}
    The figure compares two approaches to implementing the same function specification in different programming paradigms: imperative (top) and functional (bottom). The top section presents Python code, utilizing a loop and a mutable variable to accumulate sums. Conversely, the bottom section illustrates Haskell code, using a composition of two functions: \texttt{sum} and \texttt{filter}, the latter using a specified predicate in the form of an anonymous function. This exemplifies how imperative programming relies on mutable state (the \texttt{sum} variable) to track progress, whereas functional programming leverages high-level abstractions and recursion to achieve similar outcomes.    
    }
\end{figure}


Functional programming contrasts with other mainstream paradigms like object-oriented programming, which structures programs around objects combining data and behavior, and procedural programming, which focuses on a sequence of procedural steps. Despite the strengths of functional programming, object-oriented and procedural paradigms, exemplified by Java and C, respectively, remain more prevalent in commercial environments. These paradigms benefit from extensive legacy codebases, broad third-party library support, and robust tooling, and familiarity. Lastly, the strictness in functional programming languages may raise the barrier to entry for beginners. For example, in many pure function languages, printing to the terminal window, generally considered a basic technique to observe the execution of the program, exposes programmers to deep and potentially off-putting concepts like monad and side effects.  


\section{Statically-Typed Functional Languages, The Best Of Both Worlds}
Combining the disciplines described above, \textbf{statically-typed functional languages} employ both static typing and the principles of functional programming. The most common statically-typed functional languages include Haskell,  ML (with the OCaml dialect being the most popular among the family of ML languages), and F\#. 
Of these, Haskell is the only ``pure'' functional language; with all variables being immutable by default.
Descendents of Haskell, like Idris and Agda, include more advanced type-level features like dependent type and session type, allowing programmers to express extremely granular checks of potential software behavior before running the program. These languages often provide the strongest level of programming safety. It is often advertised that programs in these languages will be error-free if the source code passes the compiling stage, indicating that compilers are able to weed out a large number of programming errors. These safety properties allow statically-typed functional languages to be used as proof assistants or formal verification tools. They prove the correctness (or incorrectness) of many systems, from web public key infrastructure \cite{Bhargavan2021-no} to microcontrollers used in space programs \cite{Mokhov2019-zj}. 

Despite these safety benefits, these languages' presence in the mainstream programming world remains underwhelming. This modest popularity is often attributed to high entry barriers, unfamiliarity with the paradigms, and strict type systems that can be daunting for newcomers.

\section{Symptoms of Type Errors}
\label{sec:symptoms}
 The compiler is the medium through which programmers transform human intention into machine instructions. When encountering errors, compilers often act like Oracles in ancient history, revealing to programmers obscure messages that can lead to confusion and an incorrect remediation. Many studies have investigated the ineffectiveness of compiler error messages \cite{Barik2017-gy, Becker2019-cs, Becker2016-kc}.  Our exploration is centered around the Haskell programming language and its leading compiler, Glasgow Haskell Compiler (GHC), with the aim of enhancing its handling of type error notifications. It is vital to mention that the challenges discussed here, concerning error messages, are common across compilers for various statically-typed languages. Below, we delve into specific issues often observed in type error messages.


 \subsection{Bias in Type Errors} 
 \label{subsec:bias}
 
A significant issue in type error messages is their inherent bias. Often, type errors can arise from multiple causes, but the error message might only highlight one. This issue is known as left-to-right bias in traditional type-checking algorithmsâ€”a notable shortcoming that limits the usability of error messages \cite{McAdam2002-vb, Lee1998-fx, Chen2014-ev}. We will explore this further in Chapter \ref{chap:haskell-type-checking}. For instance, as shown in Figure \ref{fig:type-error-example}, a programmer likely intended to add two numbers using the \texttt{+} operator instead of mistakenly using the concatenation operator \texttt{++}. However, the type error issued by the compiler mistakenly points to the application of the integer literal \texttt{3}, failing to suggest the probable misuse of operators.

 \begin{figure}[hbt]
  \includegraphics[width=\linewidth]{TypeErrorExample}
  \caption{
    \label{fig:type-error-example}
    The figure illustrates a programming error scenario, featuring the source code with a type error (Top) and the corresponding compiler output (Bottom). The error likely arises from the inappropriate use of the concatenation operator \texttt{++}, rather than the addition operator \texttt{+}, on line 1, as inferred from the function name \texttt{addTwoNumbers}. Despite this, the compiler erroneously highlights line 3, where the function \texttt{addTwoNumbers} is applied to the integer \texttt{3}, boldly assuming the correctness of the \texttt{addTwoNumbers} definition. This misdirection suggests a less likely source of error, potentially complicating the debugging process.
    }
\end{figure}


\subsection{Type Error Suggests Incomplete Cause}
\label{subsec:imcomplete}

Often, type error messages do not fully present all the locations relevant to the type error. Addressing the error at the highlighted location might not suffice to resolve the underlying problem. Consider the scenario in Figure \ref{fig:type-error-example-2}, where a function intended for list concatenation is erroneously applied to integer values. Here, the error message only reports the first argument, neglecting the second. This partial reporting leads to a situation where correcting the first integer to a list format, \texttt{[3]}, doesn't rectify the error; rather, it only updates to a slightly different error message. 



\begin{figure}[hbt]
  \includegraphics[width=\linewidth]{TypeErrorExample2}
  \caption{
    \label{fig:type-error-example-2}
    This figure depicts the same program as in Figure \ref{fig:type-error-example}, with one modification being the renaming of the function from \texttt{addTwoNumbers} to \texttt{joinTwoLists}. This change shifts the implied intent towards concatenating two \texttt{List} type values. The compiler still identifies an error at the same locationâ€”the integer literal \texttt{3}â€”aligning more closely with the programmer's understanding than in the previous example. However, the error message still misleadingly overlooks the erroneous type of the second argument, \texttt{4}, as it too is an invalid input for a list concatenation operation. Therefore, modifying only the first argument is insufficient to correct the type error.
    }
\end{figure}

\subsection{Missing Links In Type Errors}
\label{subsec:missing-link}

One of the most frustrating aspects of type errors is that they do not show the complete pathway of how the compiler decided on the type error. In the example in Fig \ref{fig:type-error-example-3}, the programmer may intend to compare to a char literal \texttt{' '} instead of string literal \texttt{" "}. However, there are multiple clues that contribute to this conclusion: the definition of the function \texttt{trimWhiteSpace}, the application of \texttt{filter isSpace a}, the definition of \texttt{isSpace}, and even the type signature of \texttt{filter} are all needed to understand the logical reasoning. However, none of these are included in the actual error message.


\begin{figure}[hbt]
  \includegraphics[width=\linewidth]{TypeErrorExample3}
  \caption{
    \label{fig:type-error-example-3}
    In Haskell, the \texttt{String} type is an alias for \texttt{[Char]}, meaning the two types are equivalent. The function \texttt{trimWhiteSpace}, as used on line 3, processes a \texttt{String} (or list of \texttt{Char} values) to filter out whitespace characters. However, the functionâ€™s filter condition, \texttt{isSpace}, erroneously compares two \texttt{String} values instead of \texttt{Char} types. This is likely a type intending the char literal \texttt{' '} rather than the string literal \texttt{" "}. While the type error message correctly identifies the mismatch, it fails to provide crucial contextual clues that would obscure the nature of this error.
    }
\end{figure}


\subsection{The Use of Obscure Language}

Error messages are frequently plagued by technical jargon and convoluted phrasing, which can be particularly daunting for novices. An example is the error message, \texttt{No instance for (Num a) arising from the literal `3'}, which is an inept way of suggesting a type mismatch involving character and numeric types. In fact, this is often the common behavior across many programming languages and has been shown in many studies \cite{Barik2017-gy, Tirronen2015-nr, Prather2017-dg}. Thus, concerted efforts \cite{Becker2016-kc, Barik2014-ib}  show that rephrasing the error message to be clearer and more structured positively affects programmers' ability to solve these errors.


\section{The Challenges Of Making Good Type Errors}

After introducing some typical symptoms of bad type error messages, we will now explore some fundamental challenges that underpin these symptoms.

\subsection{Types Are Complex}

The advantages of statically typed languages derive from their robust type-checking systems, which, ironically, also introduce significant complexities. Language and tool designers frequently overlook the intrinsic complexity of type systems. In languages that support dependent types, types have the same computing capabilities as runtime programs. This complexity is not limited to dependently typed languages; for instance, type checking in common languages can exhibit Turing-complete characteristics, which might lead to non-terminating processes~\cite{Wells1999-ob}. TypeScript introduces `conditional types', a feature that allows sophisticated computations at the type level \cite{fig:ts-conditional}, posing challenges in explaining errors when these type-level computations fail due to a lack of adequate debugging tools.



\begin{figure}[hbt]
  \includegraphics[width=\linewidth]{Conditional}
  \caption{
    \label{fig:ts-conditional}
    TypeScript includes a type-level feature known as `conditional types,' which enables the declaring of a type based on the outcome of a condition check. This capability is sufficient to construct a Turing-complete language within the TypeScript type system. The figure illustrates a simple language that supports booleans, numbers (using Church encoding), and functions that operate on these values. Since this implementation is implemented entirely at the type level, it does not generate any executable code for runtime evaluation, functioning purely within the compile-time environment. The recreational value aside, these type-level features often lead to elaborated ``essay of types'', hindering understanding and usability.
    }
\end{figure}

\subsection{Clues For Type Checking May Be Implicit}

The task of understanding how types are assigned in a program grows notably more complex when the programming language employs type inference. Type inference \cite{Damas1982-sc} is a technique that allows programmers to forgo the task of writing type annotations. Instead, the type checker automatically deduces the appropriate types for each expression based on the context. Although it succeeded in providing rigorous type checking without the hassle of manually writing type annotations, type inference has been shown to bring many usability issues \cite{Jun2002-xp, Wand1986-lu} for its implicitness.  

Even in programming languages that do not utilize implicit typing, certain typing rules remain opaque to programmers. For instance, rules on permissible values for equality check using the \texttt{==} operator vary across programming languages; some languages disallow comparison of lists, and others are fine with lists but disallow comparison of floating-point numbers. In languages that support a record data type, programmers must navigate additional complexities, such as whether adding or removing a field from a record maintains type correctness \cite{fig:row-polymophism}. This often involves an understanding of nuanced language-specific rules, including concepts like covariance, contravariance, and subsumption.


\begin{figure}[hbt]
  \includegraphics[width=\linewidth]{RowPolymorphism.pdf}
  \caption{
    \label{fig:row-polymophism}
Row polymorphism is a common type level feature, allowing record values with optional more fileds to be a subtype of the record without these fields. This enhances flexibility in structuring data collections but also introduces complexity in understanding the relations between types. The figure illustrate an example where programmers try to apply the record value \texttt{alice} and \texttt{bob} to the function \texttt{greet}. Becasue the rules of row polymophism and that function arguments are covariant, only one value constitutes a valid input. 
    }
\end{figure}

These challenges amplify the difficulty in designing intuitive type error messages. The complexity of type systems demands that designers have a profound understanding of both theoretical and practical aspects of language implementationâ€”knowledge often possessed only by the core language developers. Moreover, the implicit nature of modern programming languages requires that type errors be designed on a case-by-case basis, a daunting task given the limited number of contributors who possess the necessary expertise.

\section{The Lack of Type Debugging Tools}

Debugging programming errors has been an unpleasant but crucial part of programming since the inception of computing, tracing back to as early as 1949 \cite{Campbell-Kelly1992-rn}. However, the tools and support for debugging type errors have not evolved significantly and do not match the advancement of those available for runtime errors.

One of the simplest and most dependable debugging techniques is to insert \texttt{print} statements. As computing pioneer Brian W. Kernighan once noted, ``The most effective debugging tool is careful thought, coupled with judiciously placed print statements'' \cite{Kernighan1978-xs}. Furthermore, breakpoint debugging has become a staple in nearly all programming Integrated Development Environments (IDEs), allowing for intermittent code execution and inspection \cite{fig:breakpoint}. Research in error debugging tools continues to be dynamic. For instance, ZStep94 \cite{Lieberman1995-lg} enhances traditional breakpoint debugging by eliminating the need to set breakpoints, thus enabling programmers to view and navigate through the historical values that expressions take throughout execution (Figure \ref{fig:zstep94}). Another innovative tool, WhyLine \cite{Ko2009-uf}, aligns with the principles of a natural programming environment \cite{Myers2004-fy} by allowing programmers to ask ``why'' questions and ``why not'' questions about certain program behavior.

Despite these advancements in runtime debugging tools, the development of type debugging seems to have stagnated. Most programming languages and development environments still handle type errors in ways reminiscent of early languages like FORTRAN and ALGOL. In recent years, some modern programming languages like Elm and Rust have made efforts to improve type error reporting, but these enhancements are often superficial and do not fundamentally change the debugging experience.


\begin{figure}[hbt]
  \includegraphics[width=\linewidth]{BreakPoint}
  \caption{
    \label{fig:breakpoint}
    The figure shows the debugging of a Python program using a breakpoint and expression evaluation in PyCharm, a widely-used interactive programming environment (IDE) for Python. Program execution is paused at the breakpoint set on line 4, and with each pause, the user-defined expression \texttt{i * j} is re-evaluated. This common debugging interface is available in nearly all modern programming editors and integrated development environments.
    }
\end{figure}


\begin{figure}[hbt]
  \includegraphics[width=\linewidth]{ZStep94}
  \caption{
    \label{fig:zstep94}
    Debugging a Lisp program by inspecting all the historical values of an expression, navigating through execution history, and reviewing live visualization replay.  All these features are provided in ZStep94.
    }
\end{figure}

My research is driven by the acknowledged difficulties in debugging type errors and the lack of significant advancement in the interfaces and techniques used for presenting and resolving these errors through modern graphical user interfaces and human-computer interaction techniques. This area holds considerable potential for improving both the usability and accessibility of statically typed languages, making them more approachable for developers at all levels of expertise.

\section{Research Aim}

\subsection{Aim 1. Provide Programmers With The Comprehensive Knowledge Needed to Understand and Resolve Type Errors.}
\label{subsec:aim1}

Current representations of type errors in most compiler tools are often insufficient, typically providing only the location of the type check failure, the expected type, and the actual type encountered. This conventional approach, as discussed in the previous sections (\ref{sec:symptoms}), lacks practicality and clarity. This aim addresses the need for a richer, more informative explanation of type errors by evaluating the limitations of existing systems and analyzing how programmers tackle type errors in practice.

\subsubsection{Objective 1.1 To Encompass Multiple Potential Causes Of A Type Error}
An essential aspect of this research is to challenge and expand beyond the bias found in traditional type error reporting (Section \ref{subsec:bias}). It's crucial to inform programmers of multiple potential causes and resolutions. A key goal is to communicate these multiple dimensions effectively. In addition, for each potential cause, programmers need a clear explanation of where the offending code is, which typing rules are violated, and how the type might change after the error is resolved.


\subsubsection{Objective 1.2 To Accurately Report Relevant Locations Contributing to Type Errors.}
Current tools often pinpoint a single location for a type error, a method that has attracted considerable criticism for its inefficiency. Programmers frequently need to scan beyond the initially reported location. This research aims to enhance type error reporting by identifying and detailing all relevant error-contributing locations across the codebase.

\subsubsection{Objective 1.3 To Give Reasons And Support Human Understanding}
Understanding type errors goes beyond pinpointing the location in the code. Internally, type errors can be caused by mismatched types, unmatched type class constraints, or trying to construct infinite types. Externally, type errors can be caused by typos, outdated type annotation, incomplete implementation, etc. Our goal is to not only find these errors but to explain them in a way that logically supports the programmer's understanding and troubleshooting process, covering both internal causes and external causes.



\subsection{Aim 2. Support Programmers To Type Errors Through Interactive Modern Programming Environments.}

This aim focuses on integrating comprehensive type error encoding (Section \ref{subsec:aim1}) within an interactive programming environment to streamline workflows in statically typed languages. It acknowledges that an increase in information does not necessarily correlate with enhanced understanding and aims to present type error details in a way that optimally supports comprehension and resolution.

\subsubsection{Objective 2.1 Visualize The Key Concepts Of Type Errors Effectively}

Traditional text-based error reports can be difficult to navigate and understand. This objective explores innovative methods to present what used to be displayed as plain text (type signatures, locations in source code, call stacks, dependency graphs) in a novel and intuitive way. Examples include in-line highlighting within the code editor and graph-based reasoning steps.  

\subsubsection{Objective 2.2 Use Interactive Tools for Investigating and Resolving Type Errors.}

This research will explore interactive techniques to dissect and explore type errors in a manageable and meaningful way. By breaking down errors into smaller, understandable units, programmers can methodically trace and address the root causes. This includes providing context-sensitive debugging aids that adjust the level of detail presented based on the error type and individual user preferences, ensuring a tailored and effective debugging experience.


\section{Contributions}

\subsection{A categorization of type errors based on the structure of the evidence of a type error}

To address the complexities in explaining type errors comprehensively, we have classified type errors into three complexity categories based on a human perspective. Formal definitions and a detailed discussion of these categories appear in Chapter \ref{chap:haskell-type-checking}. It is crucial to understand that these categories are not mutually exclusive; for example, a multi-witness type error may also be a multi-step type error.

A \textbf{multi-step type error} occurs through a chain of logical inferences steps based on the available evidence of the error. Figure \ref{fig:multi-step-example}) illustrates the chains of inference in the assignment of a (Line 1), the equivalence of a (Line 1 and Line 2), the assignment of b (Line 2), and the equivalence of b (Line 2 and Line 3). Removing any one of the chains will resolve the conflict. Understanding and communicating the interconnections within these chains is crucial to resolving multi-step type errors effectively.

\begin{figure}[hbt]
  \includegraphics[width=\linewidth]{Multi-Step}
  \caption{
    \label{fig:multi-step-example}
    This illustration depicts a multi-step type error in Haskell. In the program (left panel), the string literal \texttt{"True"} is assigned to the variable \texttt{a} on line 1, followed by the assignment of \texttt{a}'s value to variable \texttt{b} on line 2. Subsequently, on line 3, the program attempts to use \texttt{b} as a boolean condition in an \texttt{if} expression. The error analysis can be visualized as a "chain" of reasoning, represented by the continuous line (right panel), tracing the propagation of the type mismatch through the sequence of assignments and usage. }
\end{figure}

A \textbf{multi-witness type error} entails multiple pieces of evidence supporting the same potential type assignments. For instance, as shown in Figure \ref{fig:multi-witness-example}, multiple evidence (lines 3,4,5) support that a has the type \texttt{Int -> String}. On the other hand, a single piece of evidence (line 2) shows that a has the type \texttt{Int -> Char}.  Clarifying and juxtaposing this discrepancy in witnesses is key to supporting understanding this type of error.

\begin{figure}[hbt]
  \includegraphics[width=\linewidth]{Multi-Witness}
  \caption{
    \label{fig:multi-witness-example}
    This figure presents the analysis of a multi-witness type error in Haskell. In the source code (Left), a type conflict arises from the \texttt{case} expression which could be interpreted as \texttt{Char} based on the value in line 2, or as a \texttt{String} based on the values in lines 3, 4, and 5. The type conflict is graphically illustrated (Right) with \texttt{String} values marked in pink and the \texttt{Char} value in blue. The majority of \texttt{String} value witnesses suggests the lone \texttt{Char} literal \texttt{'I'} on line 2 might be a typographical error. This discrepancy underscores the significance of witness count in identifying the likely error source.}
\end{figure}

A \textbf{multi-party type error} involves several potential type assignments, each supported by distinct evidence.  Figure \ref{fig:multi-party-example} presents a typical multi-step type error: the expression \texttt{d} can not be assigned a type because 3 pieces of evidence on line 1 suggest 3 potential types for \texttt{d}. In practice, addressing such errors requires decomposing them into multiple type errors of simpler forms.


\begin{figure}[hbt]
  \includegraphics[width=\linewidth]{Multi-Party}
  \caption{
    \label{fig:multi-party-example}
    This figure analyzes a multi-party type error in the source code (Left), where the list \texttt{d} could potentially be typed as \texttt{[Int]}, \texttt{[String]}, or \texttt{[Char]}. The disagreement is visually represented (Right) by three distinct colors, each corresponding to the cause of one of the possible types. This scenario differs from previous examples as resolving the type error requires adjustments at multiple locations within the code, not just a single change.
       }
\end{figure}

These classifications have led to the development of three distinct systemsâ€”Chameleon, Goanna, and GeckoGraphâ€”each designed to tackle unique challenges within the domain of type error debugging.

\subsection{Explaining Multi-Step Type Errors Through Chain-Of-Thought Visualization}

\subsubsection{Technical Contribution - Chameleon}


We contribute Chameleon, an interactive Haskell debugging tool that not only identifies all relevant error-contributing locations but also illustrates the logical relationships between these locations. Chameleon provides a novel debugging interface to interactively explore the chain of reasoning in a multiple-step type error, allowing programmers to develop a panorama view of the type error interactively. In addition, Chameleon uses an adaptive interface design; programmers can switch between different granularity of information based on their personal preferences. 

\subsubsection{The evaluation on the effect of error slicing and chain of thought visualizations}
We evaluate the efficacy of interactive visual debugging tools in contrast to conventional type error debugging methods. We have conducted studies that assess how programmers resolve type errors using various interfaces ranging from basic type error slicing techniques to Chameleon's step-wise interactive debugging tools. These evaluations aim to measure how enhancements in the debugging process can influence error resolution tasks' efficiency and intuitiveness.

\subsection{Iterate potential causes of multi-witness and multi-party errors}

\subsubsection{Technical Contribution -- Goanna}
Goanna enhances type error debugging in Haskell by not only identifying all relevant error-contributing locations but also dividing the type error into possible causes and their respective resolutions. It ranks these potential causes based on their likelihood, helping programmers systematically approach error resolution.

\subsubsection{An evaluation on accuracy, conciseness, and performance of MCS-based type debugging and our heuristics}
We evaluated Goanna's performance across a diverse set of Haskell programs, analyzing its accuracy and performance in error identification against traditional tools. We evaluate Goanna's conciseness in narrowing down potential causes into a shortlist. 


\subsection{Visualizing Types}

\subsubsection{Technical Contribution -- GeckoGraph}

We contribute GeckoGraph, a graphic notation for Haskell types. GeckoGraph encodes the same information as type signatures but uses colors, shapes, and symbols to make certain structures easy to identify at a glance. GeckoGraph uses visual elements to improve the understanding of complex type concepts, such as type classes and qualified constraints. GeckoGraph offers clarity when reading dense type signatures and comparing multiple types.

\subsubsection{An evaluation on how programmers use graphic type notation}

We contribute a large-scale empirical study exploring the effectiveness of graphical type representations like GeckoGraph in enhancing programmers' abilities to tackle type-related tasks.

% \section{Research Method}

% \subsection{Human-centered programming language studies}

% One important decision that shape a lot of my work is employing human-centered research methods with our novel programming language systems. The adopting of human-centered methods happens at every stage of the projects: prototyping, development and evaluation. Although the using of these methods are not new at all, but they certainly are not the most polular choices in programming language studies.

% The motive of such decision is that it is impossible to understand what are the good qualities of type errors without observing how human use type errors to gain understanding. 


% The downside of study programming language is iterative design is very hard. programming tasks involves complex inputs and outputs, and it is very hard to study an incomplete system without a fully working systems. For instance, if we are to study the effect of type errors, it is most effective to have a system that can recognize type-correct program from ill-typed one. It is hard to evaluate with a mock-up or wizard of oz style fake outputs to study users' interaction.  To address this limitations, we have a few ideas implemented in our research:

% A minimal but practical set of language 
% Design for human from start



\section{Thesis outline}

 This thesis is structured into two main parts. The initial chapters build a comprehensive foundation on type systems and programming languages, setting the stage for my research contribution in subsequent chapters. The latter chapters focus on distinct contributions that tackle various challenges in type error debugging.

\subsection{Chapter 1}
Chapter 1 sets the stage by discussing the fundamental concepts of programming languages and type systems. It explores the trade-off between enhancing program safety and optimizing usability, a central dilemma in programming language research and software engineering practice. The chapter highlights common issues and technical challenges associated with type errors, establishing the motivation for this research. It also outlines the specific aims and contributions of the study, providing a clear roadmap for the thesis.

\subsection{Chapter 2}
This chapter delves into the fundamental concepts underlying type systems and programming languages. It outlines traditional methods employed in Haskell type checking, error slicing, and interactive debugging. Additionally, this chapter discusses tools and techniques used in constraint satisfiability analysis that are integral to later developments in the thesis. The categorization of type errors is revisited and redefined, building on the definitions introduced in this chapter.
    
\subsection{Chapter 3}
Chapter 3 presents Chameleon, a system designed to enhance the debugging of type errors through interactive visualizations. It begins with a discussion on the typical pitfalls of existing error messages and outlines the motivation behind Chameleon. We then detail the system's design, features, and development process, including iterative prototyping. A series of empirical studies were conducted to assess Chameleon's effectiveness compared to traditional compiler tools.
    
\subsection{Chapter 4}
Chapter 4 introduces Goanna, a Haskell type error debugging tool that incorporates novel features such as suggesting fixes for type errors and cross-module debugging capabilities. It starts with highlighting the limitations of conventional compiler error messages and progresses to describe Goanna's capabilities in identifying all causes and ranking potential causes by their likelihood. The implementation tactics and heuristic methods used in Goanna are discussed, followed by an empirical evaluation of the system's accuracy, conciseness, and performance based on real-world Haskell code examples.
    
\subsection{Chapter 5: GeckoGraph â€” Visualizing Haskell Types}
The final chapter synthesizes the thesis's contributions and situates them within the broader research context. It discusses potential avenues for future tool development and research opportunities, forecasting the future landscape of research in type error improvement. The chapter concludes with reflections on the expansive and still largely unexplored territories in programming languages, encouraging ongoing investigation and innovation.

    
\subsection{Chapter 6: Conclusion}
The final chapter synthesizes the thesis's contributions and situates them within the broader research context. It discusses potential avenues for future tool development and research opportunities, forecasting the future landscape of programming language research. The chapter concludes with reflections on the expansive and still largely unexplored territories in programming languages, encouraging ongoing investigation and innovation.