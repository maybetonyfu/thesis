

% \todo{As above, would start with motivation of dynamically typed langs e.g. JavaScript, Pythjon popularity but issues this brings...
% }

Dynamically typed programming languages such as JavaScript and Python have risen in popularity in recent decades \cite{chatley_next_2019}. These languages present a low barrier of entry, especially to beginner programmers: they require no type declaration, variable types or object structures can be modified dynamically, and functions can deal with dynamic input using ad-hoc polymorphism and runtime reflection. However, studies show that dynamically typed languages negatively affect development productivity \cite{kleinschmager_static_2012}, code usability \cite{mayer_empirical_2012}, and code quality \cite{gao_type_2017, ray_large-scale_2017, meyerovich_empirical_2013}. They are often found to produce error-prone code \cite{chen_empirical_2020, wang_empirical_2015,xu_python_2016} and require strong programmer discipline to avoid pitfalls \cite{chen_empirical_2020}. For these reasons, many modern dynamically-typed languages have introduced static typing annotations as part of the core language features in recent years (e.g.\ \textit{TypeScript}~\cite{microsoft_javascript_nodate} and \textit{mypy}~\cite{mypy_mypy_nodate}).

Functional programming languages have long enjoyed rigorous type systems and expressive type-level features. Techniques such as type inference and algebraic types have been standard practice for decades in functional languages such as ML and Haskell, and more recently in multi-paradigm languages, such as Rust and TypeScript. Various type system advances were introduced in Haskell and ended up in mainstream languages years or even decades after, leading many to consider Haskell the ``type-system laboratory" \cite{hudak_history_2007}.  Type classes, an implementation of generic programming, were introduced to Haskell in 1988~\cite{hudak_history_2007}, and now can be found in most popular languages such as C\#~\cite{bill_wagner_constraints_2022}, Java~\cite{oracle_generic_2022}, and TypeScript~\cite{microsoft_documentation_2022}.

One crucial challenge of programming in statically-typed languages is that type errors can sometimes be difficult to resolve~\cite{tirronen_understanding_2015, hage_solved_2020}. In particular, they may point to locations that are not the root  causes of the type error, expose errors in cryptic language, or provide misleading fixing suggestions~\cite{wu_how_2017}.
% Compared to dynamic type systems, static type systems offer programmers opportunities to weed out a large number of errors at compile time (reducing the need for run-time debugging) and to increase usability~\cite{mayer_static_2012} and codebase maintainability~\cite{kleinschmager_static_2012}. In recent years, the programming community has seen a trend of migrating away from dynamically typed codebases due to the lack of maintainability and refactoring safety when systems reach large scale and complexity~\cite{chatley_next_2019}. These migration methods include the introduction of gradual type annotations (e.g., JavaScript to TypeScript or Python with mypy) or transition to a modern strongly-typed language (Scala, Rust, Haskell, PureScript, etc.). However, with dynamically typed languages (e.g., JavaScript, PHP, and Python) still being most peoples' formative experience with programming and with such languages now firmly entrenched in education~\cite{stackoverflow_stack_2022}, this transition may pose difficulties for programmers who lack experience writing type-safe programs.

% \todo{There are a lot of minor grammer fix-ups needed throughout...}
% Programmers find challenges in adopting typed languages in their practice. \todo{I think this statement is plain wrong myself... 
%  Need strong references to justify if going to say this to SE audience!:}They tend to be verbose, hard to learn and generate bad error messages. 
% One obstacle programmers face when using a statically typed language is understanding and resolving type errors~\cite{marceau_measuring_2011, tirronen_understanding_2015}, especially when dealing with modern type features such as polymorphic types and implicit typing. Studies show most statically typed languages produce unhelpful and even misleading type errors~\cite{}. Symptoms of bad error messages include cryptic language exposing internal constructs of the compiler and incomplete or wrong error locations. These usability issues pose challenges to learners and teachers of the languages. impede the wide adoption of statically typed languages, especially for programmers who are now accustomed to the mindset of writing un-typed programs.

This paper introduces \chameleon{}, an interactive type debugging tool for Haskell. It can visualize the relevant context of a type error: where it happens or could have happened and which parts of the code cause it. In addition, \chameleon{} allows programmers to interactively explore all the parts of code where multiple types can be inferred and to resolve ambiguity. The most noticeable features are the type compare tool (Section \ref{sub:type-compare}), the candidate expression card (Section \ref{sub:candidate-expression}), and the deduction step (Section \ref{sub:deduction-steps}). These features are integrated into a debugging environment and can be enabled or disabled separately based on the programmers' preferences and debugging needs. \chameleon{} is open-source and is available at ~\cite{anonymous_chameleon_2022}.  
% \todo{Introduce Haskell earlier?  Motivate WHY Haskell?} The current implementation of \chameleon{} targets the Haskell 2010 language standard. However, it is planned to extend it to support other programming languages using the same underlying ideas and techniques. Historically, Haskell has been a test bed for advanced language features, and it is common for features established in Haskell to be transferred to mainstream programming languages. 

% \chameleon{} uses underlying type inference algorithms adapted from the command-line tool, Chameleon, developed in 2005 \cite{chameleon}. As described in Section \ref{sec:typeinferenceengine}, Chameleon computes the Minimum Unsatisfiable Subset (MUS) \tf{Explain what mus is} of type constraints in order to identify a set of code locations where multiple types can be inferred. Compared to standard compiler messages, which arbitrarily report the first place a type conflict arises, Chameleon error messages give a lot more context to the programmer to help them correctly resolve the conflict to match the program's intent. However, the Chameleon system was never tested with users.  Therefore, the first contribution of this paper is to address the research question: \textit{Is a minimally interactive version of Chameleon's multipart type-conflict display more effective in supporting type error debugging than traditional error messages? } (Sections~\ref{sub:us1} and \ref{sub:us2}).

% After affirming that the information Chameleon provides is beneficial for more complex type errors, we ask \textit{Do programmers benefit from the interactive exploration of type error locations?} (Sections~\ref{sub:us3} and \ref{sub:us4}). We then explore \textit{How do programmers use the interactive exploration features to solve type errors?}  (Section~\ref{sub:us4}).


This paper makes the following contributions:
\begin{itemize}
\item We provide the design and implementation of the \chameleon{} to visualize the relevant context of a type error and allow programmers to explore and verify the error locations in small chunks interactively.  
\item {
    We report the results of three experiments designed to evaluate \chameleon{}.}
\end{itemize}

Our experiments showed that programmers using \chameleon{} fix type errors faster than with traditional text-based error messages. This difference is more significant when solving harder tasks. Further, programmers who actively use \chameleon{} interactive features fix type errors faster than simply reading the type error output. Although \chameleon{} is designed to work with
the Haskell language, we plan to extend the underlying ideas to work with other strongly typed languages, such as Rust or TypeScript..