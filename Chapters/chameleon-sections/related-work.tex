\section{Related Work}

% \todo{I would do a short Motivating Example section straight after intro showing example of untyped lang, problems it brings, and outline requirments for the proposed IDE to address it. Make sense??}

% \todo{Do yoou need Related Work here - or put @ end of paper just before Summary - I tend to do the later now UNLESS its REALLY needed by reader - IMO could put @ end and get to your work/contributions much quicker}

\subsection{Finding all type error locations}
Many have studied the approach of finding all locations that contribute to a type error~\cite{stuckey_interactive_2003, haack_type_2004, pavlinovic_practical_2015, schilling_constraint-free_2012}. Type error slicing~\cite{haack_type_2004} is a technique that finds locations that are complete and minimal for the type error. Internally labeled constraints and Minimal Unsatisfiable Subset (MUS) generation are used to generate these slices. The language supported in Haack's work was a subset of Standard ML. The original Chameleon~\cite{stuckey_interactive_2003} used  Constraint handling rules (CHR) to support the computing of type error slices in Haskell. Chameleon also supported advanced type-level features (type classes and functionally dependent types). The project also introduced the ability to query type information through a command line interface. Although Chameleon was firmly grounded in results from type theory, its designs were never evaluated with user studies. While finding all error locations is useful in comprehending type errors, it is only 1 of the 7 properties listed in the proposed manifesto of good type error reporting~\cite{yang_improved_2000}.
To the best of our knowledge, ours is the first user-centered evaluation of an interactive type debugging system involving type-error slicing.


\subsection{Producing high-quality error explanation}
One weakness of compiler error messages, in general, is that they fail to explain the error in human language. As put in~\cite{barik_developers_2017}, ``Error messages appear to take the form of natural language, yet are as difficult to read as source code."  A well-studied approach to producing better error explanations is through ECEM (Enhanced compiler error message). Through a series of mixed-method studies, Prather showed~\cite{prather_novices_2017} that ECEM has a positive result in understanding compiler errors. Decaf~\cite{becker_effective_2016} is a tool that can rephrase Java compiler error messages into an enhanced version. In a study of over 200 CS1 students, Decaf was shown to reduce overall errors in their coding practices. Berik proposed a framework~\cite{barik_how_2018} for constructing compiler error messages based on argumentation theory, and showed that error messages following a simple argumentation layout or an extended argumentation layout are more human-friendly.  These works show the significance of improving the language in the compiler error messages. Most principles and suggestions are followed in \chameleon{} in constructing error statements. However, these earlier studies were not targeting type errors alone but general compiler errors (some even include runtime errors). The nuances of type errors, such as alternative typing, were not considered. Moreover, these explanation systems were designed specifically for novice users. 


% \subsection{Suggesting resolution}
% One direction to approach type error debugging is by suggesting solutions to fix the type error. Sheng Chen's works~\cite{chen_counter-factual_2014, chen_efficient_2020, chen_improving_2022} on counterfactual typing are able to suggest changes to make the ill-typed program type-check.  Lerner  studied an approach~\cite{lerner_searching_2007} of repeatedly modifying the AST (abstract syntax tree) and querying the compiler/type checker to know whether the new program is well-typed. This approach allows the algorithm to suggest syntax changes that could fix the type error. Benefiting from not needing a type system implementation and being language agnostic, the underlying idea was implemented and evaluated in two different languages with ten university students. While suggesting syntax changes is very intuitive in practice, this approach has limitations for teaching and learning purposes, as it is not able to explain why the type errors occur and why fixes are suggested. The lack of explanation is due to the inquiry into the underlying type-check being a binary state. Deep type-level analysis (typing rules and language features) was not communicated to the inference algorithm.


\subsection{Interactive Debugging}
% The original Chameleon provides a certain level of ``interactive'' debugging through a command-line interface~\cite{stuckey_interactive_2003}, allowing the programmer to query different parts of the program. A recent study \cite{tsushima_type_2021} provided an interactive type debugging system that restores type information based on the output from CFT (Counter-factual typing)~\cite{chen_counter-factual_2014, chen_efficient_2020, chen_improving_2022} inference. Both tools allow programmers to change their assumptions about which expression is ill-typed. While both tools show a strong influence on theoretical development, they were not evaluated in realistic studies with human participants. In addition, command line-based debugging tools suffer the same limitation as other line-based tools, namely, limited user interaction, limited graphic capability (ANSI text), and the requirement of remembering the command language. 


Modern programming tools can offer alternative methods of code authoring, display real-time feedback and reveal complex programming contexts through visualizations. Many tools aim to improve the debugging experience using such capabilities. We list two. Hazel Tutor \cite{potter_hazel_2020} is an interactive type-driven environment for the OCaml language. It can automatically fill type holes by suggesting template expressions (called ``strategies'' by the authors) through a popup window. It also provides a cursor-based type inspector that allows programmers to query the types of different parts of the program. Whyline~\cite{ko_finding_2009} is a Java debugging system that allows a user to ask questions like ``why does variable X have value Y." It also allows users to interactively ask follow-up questions to gain further knowledge of the nature of an error. These debugging tools are important motivations for developing \chameleon{}. However, they focus on different aspects of the debugging process. Java Whyline mainly tackles the problem of unintended runtime behavior, while Hazel Tutor specializes in development assistance supported by type holes.





% A few studies \cite{yang1999explaining, jun2002explaining} focus on explain type error in particular. Yang~\cite{jun2002explaining} showed an alternative type inference system capable of producing a human-like text explanation for why expressions are assigned certain types. A good explanation is drawn from surveying how human experts explain types. The resulting algorithm $\mathcal{H}$, generates a succinct explanation of the type inference steps to avoid using internal constructs (such as type variables). The explanation system has the advantage of acting like a human expert. However, when presented as text-based output, explanation systems have the potential to become verbose when types are complex or variable names are long. 