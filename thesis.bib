
@article{lindley_idioms_2011,
	title = {Idioms are Oblivious, Arrows are Meticulous, Monads are Promiscuous},
	volume = {229},
	issn = {15710661},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1571066111000557},
	doi = {10.1016/j.entcs.2011.02.018},
	abstract = {We revisit the connection between three notions of computation: Moggi’s monads, Hughes’s arrows and {McBride} and Paterson’s idioms (also called applicative functors). We show that idioms are equivalent to arrows that satisfy the type isomorphism A ; B 1 ; (A → B) and that monads are equivalent to arrows that satisfy the type isomorphism A ; B A → (1 ; B). Further, idioms embed into arrows and arrows embed into monads.},
	pages = {97--117},
	number = {5},
	journaltitle = {Electronic Notes in Theoretical Computer Science},
	shortjournal = {Electronic Notes in Theoretical Computer Science},
	author = {Lindley, Sam and Wadler, Philip and Yallop, Jeremy},
	urldate = {2021-01-04},
	date = {2011-03},
	langid = {english},
	file = {Lindley et al. - 2011 - Idioms are Oblivious, Arrows are Meticulous, Monad.pdf:/Users/tony.f/Zotero/storage/DYCLUZ6M/Lindley et al. - 2011 - Idioms are Oblivious, Arrows are Meticulous, Monad.pdf:application/pdf},
}

@article{jung_visualisation_2000,
	title = {A visualisation of polymorphic type checking},
	volume = {10},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796899003597/type/journal_article},
	doi = {10.1017/S0956796899003597},
	abstract = {The understanding of polymorphic typechecking and type errors is poorly supported by contemporary functional language implementations. Here, a novel visualisation of functions and their types is presented based on the generation of function speci c icons with graphical type representations which change dynamically as functions are applied. This visualisation has been implemented for a Standard {ML} subset within a graphical environment in which function combinations are constrained by type matching.},
	pages = {57--75},
	number = {1},
	journaltitle = {Journal of Functional Programming},
	shortjournal = {J. Funct. Prog.},
	author = {Jung, Yang and Michaelson, Greg},
	urldate = {2021-01-04},
	date = {2000-01},
	langid = {english},
	file = {Jung and Michaelson - 2000 - A visualisation of polymorphic type checking.pdf:/Users/tony.f/Zotero/storage/44T96YEM/Jung and Michaelson - 2000 - A visualisation of polymorphic type checking.pdf:application/pdf},
}

@article{jones_system_1995,
	title = {A system of constructor classes: overloading and implicit higher-order polymorphism},
	volume = {5},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796800001210/type/journal_article},
	doi = {10.1017/S0956796800001210},
	shorttitle = {A system of constructor classes},
	abstract = {This paper describes a exible type system which combines overloading and higher-order polymorphism in an implicitly typed language using a system of constructor classes \{ a natural generalization of type classes in Haskell.},
	pages = {1--35},
	number = {1},
	journaltitle = {Journal of Functional Programming},
	shortjournal = {J. Funct. Prog.},
	author = {Jones, Mark P.},
	urldate = {2021-01-04},
	date = {1995-01},
	langid = {english},
	file = {Jones - 1995 - A system of constructor classes overloading and i.pdf:/Users/tony.f/Zotero/storage/VCBQUPII/Jones - 1995 - A system of constructor classes overloading and i.pdf:application/pdf},
}

@article{grant_hindley-milner_nodate,
	title = {The Hindley-Milner Type Inference Algorithm},
	abstract = {The Hindley-Milner algorithm is described and an implementation in Standard {ML} is presented.},
	pages = {30},
	author = {Grant, Ian},
	langid = {english},
	file = {Grant - The Hindley-Milner Type Inference Algorithm.pdf:/Users/tony.f/Zotero/storage/DIL67A9U/Grant - The Hindley-Milner Type Inference Algorithm.pdf:application/pdf},
}

@article{gibbons_essence_nodate,
	title = {The Essence of the Iterator Pattern},
	abstract = {The {ITERATOR} pattern gives a clean interface for element-by-element access to a collection, independent of the collection’s shape. Imperative iterations using the pattern have two simultaneous aspects: mapping and accumulating. Various existing functional models of iteration capture one or other of these aspects, but not both simultaneously. We argue that {McBride} and Paterson’s applicative functors, and in particular the corresponding traverse operator, do exactly this, and therefore capture the essence of the {ITERATOR} pattern. Moreover, they do so in a way that nicely supports modular programming. We present some axioms for traversal, discuss modularity concerns, and illustrate with a simple example, the wordcount problem.},
	pages = {25},
	author = {Gibbons, Jeremy and Building, Wolfson and Road, Parks},
	langid = {english},
	file = {Gibbons et al. - The Essence of the Iterator Pattern.pdf:/Users/tony.f/Zotero/storage/9W6W7M24/Gibbons et al. - The Essence of the Iterator Pattern.pdf:application/pdf},
}

@thesis{geest_constraints_2007,
	location = {P.O. Box 80.089 3508 {TB} Utrecht The Netherlands},
	title = {Constraints for Type Class Extensions},
	pagetotal = {76},
	institution = {Universiteit Utrecht},
	type = {phdthesis},
	author = {Geest, Gerrit van den},
	date = {2007-02},
	file = {Geest - 2007 - Constraints for Type Class Extensions.pdf:/Users/tony.f/Zotero/storage/5ZUJCHDC/Geest - 2007 - Constraints for Type Class Extensions.pdf:application/pdf},
}

@incollection{schrijvers_welcome_2008,
	location = {Berlin, Heidelberg},
	title = {Welcome to Constraint Handling Rules},
	volume = {5388},
	isbn = {978-3-540-92242-1 978-3-540-92243-8},
	url = {http://link.springer.com/10.1007/978-3-540-92243-8_1},
	abstract = {Constraint Handling Rules ({CHR}) is a declarative concurrent committed-choice constraint logic programming language consisting of guarded rules that transform multisets of relations called constraints until no more change occurs. As an introduction to {CHR} as a generalpurpose programming language we present some small programs using diﬀerent programming styles and discuss their properties.},
	pages = {1--15},
	booktitle = {Constraint Handling Rules},
	publisher = {Springer Berlin Heidelberg},
	author = {Frühwirth, Thom},
	editor = {Schrijvers, Tom and Frühwirth, Thom},
	urldate = {2021-01-04},
	date = {2008},
	langid = {english},
	doi = {10.1007/978-3-540-92243-8_1},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Frühwirth - 2008 - Welcome to Constraint Handling Rules.pdf:/Users/tony.f/Zotero/storage/GZCYMM4I/Frühwirth - 2008 - Welcome to Constraint Handling Rules.pdf:application/pdf},
}

@inproceedings{damas_principal_1982,
	location = {Albuquerque, Mexico},
	title = {Principal type-schemes for functional programs},
	isbn = {978-0-89791-065-1},
	url = {http://portal.acm.org/citation.cfm?doid=582153.582176},
	doi = {10.1145/582153.582176},
	eventtitle = {the 9th {ACM} {SIGPLAN}-{SIGACT} symposium},
	pages = {207--212},
	booktitle = {Proceedings of the 9th {ACM} {SIGPLAN}-{SIGACT} symposium on Principles of programming languages  - {POPL} '82},
	publisher = {{ACM} Press},
	author = {Damas, Luis and Milner, Robin},
	urldate = {2021-01-04},
	date = {1982},
	langid = {english},
	file = {Damas and Milner - 1982 - Principal type-schemes for functional programs.pdf:/Users/tony.f/Zotero/storage/EPPXD3ZG/Damas and Milner - 1982 - Principal type-schemes for functional programs.pdf:application/pdf},
}

@thesis{wazny_type_2006,
	location = {Parkville, Melbourne},
	title = {Type inference and type error diagnosis for Hindley/Milner with extensions},
	pagetotal = {253},
	institution = {University of Melbourne},
	type = {phdthesis},
	author = {Wazny, Jeremy Richard},
	date = {2006-01},
	file = {Wazny - 2006 - Type inference and type error diagnosis for Hindle.pdf:/Users/tony.f/Zotero/storage/M66H6MAK/Wazny - 2006 - Type inference and type error diagnosis for Hindle.pdf:application/pdf},
}

@inproceedings{duboscq_intermediate_2013,
	location = {Indianapolis, Indiana, {USA}},
	title = {An intermediate representation for speculative optimizations in a dynamic compiler},
	isbn = {978-1-4503-2601-8},
	url = {http://dl.acm.org/citation.cfm?doid=2542142.2542143},
	doi = {10.1145/2542142.2542143},
	abstract = {We present a compiler intermediate representation ({IR}) that allows dynamic speculative optimizations for high-level languages. The {IR} is graph-based and contains nodes ﬁxed to control ﬂow as well as ﬂoating nodes. Side-effecting nodes include a framestate that maps values back to the original program. Guard nodes dynamically check assumptions and, on failure, deoptimize to the interpreter that continues execution. Guards implicitly use the framestate and program position of the last side-effecting node. Therefore, they can be represented as freely ﬂoating nodes in the {IR}. Exception edges are modeled as explicit control ﬂow and are subject to full optimization. We use proﬁling and deoptimization to speculatively reduce the number of such edges. The {IR} is the core of a just-in-time compiler that is integrated with the Java {HotSpot} {VM}. We evaluate the design decisions of the {IR} using major Java benchmark suites.},
	eventtitle = {the 7th {ACM} workshop},
	pages = {1--10},
	booktitle = {Proceedings of the 7th {ACM} workshop on Virtual machines and intermediate languages - {VMIL} '13},
	publisher = {{ACM} Press},
	author = {Duboscq, Gilles and Würthinger, Thomas and Stadler, Lukas and Wimmer, Christian and Simon, Doug and Mössenböck, Hanspeter},
	urldate = {2021-01-04},
	date = {2013},
	langid = {english},
	file = {Duboscq et al. - 2013 - An intermediate representation for speculative opt.pdf:/Users/tony.f/Zotero/storage/D6SSUDAX/Duboscq et al. - 2013 - An intermediate representation for speculative opt.pdf:application/pdf},
}

@misc{ferdowsi_usability_2023,
	title = {The Usability of Advanced Type Systems: Rust as a Case Study},
	url = {http://arxiv.org/abs/2301.02308},
	shorttitle = {The Usability of Advanced Type Systems},
	abstract = {Advanced type systems that enforce various correctness and safety guarantees--such as linear and ownership types--have a long history in the Programming Languages research community. Despite this history, a human-centered evaluation of these type systems and their usability was all but absent, with empirical evaluations limited to testing their expressiveness in programs written by experts, i.e. the creators of the type system. In the past few years, this has begun to change with the adoption of a version of affine types and ownership in the popular Rust programming language. With the increase in Rust's popularity, various studies have begun empirically evaluating the usability of Rust's Ownership and Lifetime rules, providing a breadth of qualitative and quantitative information on the usability of such type systems. They found that despite Rust's general success in achieving its promise of safety and performance, these rules come with a steep learning curve and have been repeatedly cited as a barrier to adopting Rust. In this report, I provide a brief history of linear types and region-based memory management, which directly inspired Rust's type system. I then introduce Rust's Ownership and Lifetime rules, and present the state-of-the-art in academic research into their usability. I discuss both theoretical arguments and empirical evidence for why these rules are difficult to learn and apply, and survey existing work on addressing some of these difficulties. I also draw from broader works in the {HCI} and {CS} Education communities to recommend future work in this area.},
	number = {{arXiv}:2301.02308},
	publisher = {{arXiv}},
	author = {Ferdowsi, Kasra},
	urldate = {2023-02-23},
	date = {2023-01-05},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {2301.02308 [cs]},
	keywords = {Computer Science - Human-Computer Interaction, Computer Science - Programming Languages},
	file = {Ferdowsi - 2023 - The Usability of Advanced Type Systems Rust as a .pdf:/Users/tony.f/Zotero/storage/JZUIHBZB/2301.02308.pdf:application/pdf},
}

@article{loh_implementation_nodate,
	title = {An Implementation of a Dependently Typed Lambda Calculus},
	abstract = {We present an implementation in Haskell of a dependently-typed lambda calculus that can be used as the core of a programming language. We show that a dependently-typed lambda calculus is no more difﬁcult to implement than other typed lambda calculi. In fact, our implementation is almost as easy as an implementation of the simply typed lambda calculus, which we emphasize by discussing the modiﬁcations necessary to go from one to the other. We explain how to add data types and write simple programs in the core language, and discuss the steps necessary to build a full-ﬂedged programming language on top of our simple core.},
	author = {Loh, Andres and {McBride}, Conor and Swierstra, Wouter},
	langid = {english},
	file = {Loh et al. - An Implementation of a Dependently Typed Lambda Ca.pdf:/Users/tony.f/Zotero/storage/4IZMJTDX/Loh et al. - An Implementation of a Dependently Typed Lambda Ca.pdf:application/pdf},
}

@incollection{gaspers_improving_2017,
	location = {Cham},
	title = {Improving {MCS} Enumeration via Caching},
	volume = {10491},
	isbn = {978-3-319-66262-6 978-3-319-66263-3},
	url = {http://link.springer.com/10.1007/978-3-319-66263-3_12},
	abstract = {Enumeration of minimal correction sets ({MCSes}) of conjunctive normal form formulas is a central and highly intractable problem in infeasibility analysis of constraint systems. Often complete enumeration of {MCSes} is impossible due to both high computational cost and worst-case exponential number of {MCSes}. In such cases partial enumeration is sought for, ﬁnding applications in various domains, including axiom pinpointing in description logics among others. In this work we propose caching as a means of further improving the practical efﬁciency of current {MCS} enumeration approaches, and show the potential of caching via an empirical evaluation.},
	pages = {184--194},
	booktitle = {Theory and Applications of Satisfiability Testing – {SAT} 2017},
	publisher = {Springer International Publishing},
	author = {Previti, Alessandro and Mencía, Carlos and Järvisalo, Matti and Marques-Silva, Joao},
	editor = {Gaspers, Serge and Walsh, Toby},
	urldate = {2023-01-29},
	date = {2017},
	langid = {english},
	doi = {10.1007/978-3-319-66263-3_12},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Previti et al. - 2017 - Improving MCS Enumeration via Caching.pdf:/Users/tony.f/Zotero/storage/MSR9DLS2/Previti et al. - 2017 - Improving MCS Enumeration via Caching.pdf:application/pdf},
}

@inproceedings{pavlinovic_finding_2014,
	location = {Portland Oregon {USA}},
	title = {Finding minimum type error sources},
	isbn = {978-1-4503-2585-1},
	url = {https://dl.acm.org/doi/10.1145/2660193.2660230},
	doi = {10.1145/2660193.2660230},
	abstract = {Automatic type inference is a popular feature of functional programming languages. If a program cannot be typed, the compiler typically reports a single program location in its error message. This location is the point where the type inference failed, but not necessarily the actual source of the error. Other potential error sources are not even considered. Hence, the compiler often misses the true error source, which increases debugging time for the programmer. In this paper, we present a general framework for automatic localization of type errors. Our algorithm ﬁnds all minimum error sources, where the exact deﬁnition of minimum is given in terms of a compiler-speciﬁc ranking criterion. Compilers can use minimum error sources to produce more meaningful error reports, and for automatic error correction. Our approach works by reducing the search for minimum error sources to an optimization problem that we formulate in terms of weighted maximum satisﬁability modulo theories ({MaxSMT}). The reduction to weighted {MaxSMT} allows us to build on {SMT} solvers to support rich type systems and at the same time abstract from the concrete criterion that is used for ranking the error sources. We have implemented an instance of our framework targeted at Hindley-Milner type systems and evaluated it on existing {OCaml} benchmarks for type error localization. Our evaluation shows that our approach has the potential to signiﬁcantly improve the quality of type error reports produced by state of the art compilers.},
	eventtitle = {{SPLASH} '14: Conference on Systems, Programming, and Applications: Software for Humanity},
	pages = {525--542},
	booktitle = {Proceedings of the 2014 {ACM} International Conference on Object Oriented Programming Systems Languages \& Applications},
	publisher = {{ACM}},
	author = {Pavlinovic, Zvonimir and King, Tim and Wies, Thomas},
	urldate = {2023-01-24},
	date = {2014-10-15},
	langid = {english},
	file = {Pavlinovic et al. - 2014 - Finding minimum type error sources.pdf:/Users/tony.f/Zotero/storage/ILDY7P3B/Pavlinovic et al. - 2014 - Finding minimum type error sources.pdf:application/pdf},
}

@online{haskell_haskell_nodate,
	title = {Haskell Extension for Visual Studio Code},
	url = {https://marketplace.visualstudio.com/items?itemName=haskell.haskell},
	author = {{Haskell}},
	urldate = {2022-12-12},
}

@online{microsoft_visual_nodate,
	title = {Visual Studio Code - Code Editing. Redefined},
	url = {https://code.visualstudio.com/},
	abstract = {Visual Studio Code is a code editor redefined and optimized for building and debugging modern web and cloud applications.  Visual Studio Code is free and available on your favorite platform - Linux, {macOS}, and Windows.},
	author = {{Microsoft}},
	urldate = {2022-12-12},
	langid = {english},
	file = {Snapshot:/Users/tony.f/Zotero/storage/K2PK87KP/code.visualstudio.com.html:text/html},
}

@online{microsoft_javascript_nodate,
	title = {{JavaScript} With Syntax For Types.},
	url = {https://www.typescriptlang.org/},
	abstract = {{TypeScript} extends {JavaScript} by adding types to the language. {TypeScript} speeds up your development experience by catching errors and providing fixes before you even run your code.},
	author = {{Microsoft}},
	urldate = {2022-12-12},
	langid = {english},
	file = {Snapshot:/Users/tony.f/Zotero/storage/ZNXY8BRD/www.typescriptlang.org.html:text/html},
}

@online{anonymous_chameleon_2022,
	title = {Chameleon Type Debugger},
	url = {https://chameleon.typecheck.me/},
	author = {{Anonymous}},
	urldate = {2022-12-01},
	date = {2022},
	file = {Chameleon Type Debugger:/Users/tony.f/Zotero/storage/7ABZKGSA/chameleon.typecheck.me.html:text/html},
}

@inproceedings{anonymous_interactive_2021,
	location = {Virtual},
	title = {Interactive Haskell Type Inference Exploration (Extended Abstract)},
	url = {https://icfp21.sigplan.org/details/TyDe-2021/6/Interactive-Haskell-Type-Inference-Exploration-Extended-Abstract-},
	eventtitle = {{ICFP} (Workshop on Type-Driven Development)},
	author = {{Anonymous}},
	urldate = {2022-12-09},
	date = {2021},
	file = {Snapshot:/Users/tony.f/Zotero/storage/3QSIPE2H/Interactive-Haskell-Type-Inference-Exploration-Extended-Abstract-.html:text/html},
}

@online{mypy_mypy_nodate,
	title = {mypy - Optional Static Typing for Python},
	url = {http://mypy-lang.org/},
	author = {{mypy}},
	urldate = {2022-12-07},
	file = {mypy - Optional Static Typing for Python:/Users/tony.f/Zotero/storage/8ALE9S5L/mypy-lang.org.html:text/html},
}

@article{hage_solved_2020,
	title = {Solved and Open Problems in Type Error Diagnosis},
	abstract = {The purpose of this paper is to present a number of directions for future research in type error diagnosis. To be able to position these open problems, we ﬁrst discuss accomplishments in the ﬁeld without trying to be exhaustive.},
	pages = {13},
	author = {Hage, Jurriaan},
	date = {2020},
	langid = {english},
}

@inproceedings{wang_empirical_2015,
	title = {An empirical study on the impact of Python dynamic features on change-proneness},
	doi = {10.18293/SEKE2015-097},
	pages = {134--139},
	author = {Wang, Beibei and Chen, Lin and Ma, Wanwangying and Chen, Zhifei and Xu, Baowen},
	date = {2015-07-01},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/QQ8UG334/Wang et al. - 2015 - An empirical study on the impact of Python dynamic.pdf:application/pdf},
}

@inproceedings{xu_python_2016,
	location = {New York, {NY}, {USA}},
	title = {Python predictive analysis for bug detection},
	isbn = {978-1-4503-4218-6},
	url = {https://doi.org/10.1145/2950290.2950357},
	doi = {10.1145/2950290.2950357},
	series = {{FSE} 2016},
	abstract = {Python is a popular dynamic language that allows quick software development. However, Python program analysis engines are largely lacking. In this paper, we present a Python predictive analysis. It first collects the trace of an execution, and then encodes the trace and unexecuted branches to symbolic constraints. Symbolic variables are introduced to denote input values, their dynamic types, and attribute sets, to reason about their variations. Solving the constraints identifies bugs and their triggering inputs. Our evaluation shows that the technique is highly effective in analyzing real-world complex programs with a lot of dynamic features and external library calls, due to its sophisticated encoding design based on traces. It identifies 46 bugs from 11 real-world projects, with 16 new bugs. All reported bugs are true positives.},
	pages = {121--132},
	booktitle = {Proceedings of the 2016 24th {ACM} {SIGSOFT} International Symposium on Foundations of Software Engineering},
	publisher = {Association for Computing Machinery},
	author = {Xu, Zhaogui and Liu, Peng and Zhang, Xiangyu and Xu, Baowen},
	urldate = {2022-12-04},
	date = {2016-11-01},
	keywords = {Debugging, Dynamic Language, Predictive Analysis, Python},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/6QVX45QA/Xu et al. - 2016 - Python predictive analysis for bug detection.pdf:application/pdf},
}

@article{ray_large-scale_2017,
	title = {A large-scale study of programming languages and code quality in {GitHub}},
	volume = {60},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/3126905},
	doi = {10.1145/3126905},
	abstract = {What is the effect of programming languages on software quality? This question has been a topic of much debate for a very long time. In this study, we gather a very large data set from {GitHub} (728 projects, 63 million {SLOC}, 29,000 authors, 1.5 million commits, in 17 languages) in an attempt to shed some empirical light on this question. This reasonably large sample size allows us to use a mixed-methods approach, combining multiple regression modeling with visualization and text analytics, to study the effect of language features such as static versus dynamic typing and allowing versus disallowing type confusion on software quality. By triangulating findings from different methods, and controlling for confounding effects such as team size, project size, and project history, we report that language design does have a significant, but modest effect on software quality. Most notably, it does appear that disallowing type confusion is modestly better than allowing it, and among functional languages, static typing is also somewhat better than dynamic typing. We also find that functional languages are somewhat better than procedural languages. It is worth noting that these modest effects arising from language design are overwhelmingly dominated by the process factors such as project size, team size, and commit size. However, we caution the reader that even these modest effects might quite possibly be due to other, intangible process factors, for example, the preference of certain personality types for functional, static languages that disallow type confusion.},
	pages = {91--100},
	number = {10},
	journaltitle = {Communications of the {ACM}},
	shortjournal = {Commun. {ACM}},
	author = {Ray, Baishakhi and Posnett, Daryl and Devanbu, Premkumar and Filkov, Vladimir},
	urldate = {2022-12-05},
	date = {2017-09-25},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/RIRXSPMD/Ray et al. - 2017 - A large-scale study of programming languages and c.pdf:application/pdf},
}

@inproceedings{meyerovich_empirical_2013,
	location = {New York, {NY}, {USA}},
	title = {Empirical analysis of programming language adoption},
	isbn = {978-1-4503-2374-1},
	url = {https://doi.org/10.1145/2509136.2509515},
	doi = {10.1145/2509136.2509515},
	series = {{OOPSLA} '13},
	abstract = {Some programming languages become widely popular while others fail to grow beyond their niche or disappear altogether. This paper uses survey methodology to identify the factors that lead to language adoption. We analyze large datasets, including over 200,000 {SourceForge} projects, 590,000 projects tracked by Ohloh, and multiple surveys of 1,000-13,000 programmers. We report several prominent findings. First, language adoption follows a power law; a small number of languages account for most language use, but the programming market supports many languages with niche user bases. Second, intrinsic features have only secondary importance in adoption. Open source libraries, existing code, and experience strongly influence developers when selecting a language for a project. Language features such as performance, reliability, and simple semantics do not. Third, developers will steadily learn and forget languages. The overall number of languages developers are familiar with is independent of age. Finally, when considering intrinsic aspects of languages, developers prioritize expressivity over correctness. They perceive static types as primarily helping with the latter, hence partly explaining the popularity of dynamic languages.},
	pages = {1--18},
	booktitle = {Proceedings of the 2013 {ACM} {SIGPLAN} international conference on Object oriented programming systems languages \& applications},
	publisher = {Association for Computing Machinery},
	author = {Meyerovich, Leo A. and Rabkin, Ariel S.},
	urldate = {2022-12-04},
	date = {2013-10-29},
	keywords = {programming language adoption, survey research},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/PSJXKLZZ/Meyerovich and Rabkin - 2013 - Empirical analysis of programming language adoptio.pdf:application/pdf},
}

@inproceedings{gao_type_2017,
	title = {To Type or Not to Type: Quantifying Detectable Bugs in {JavaScript}},
	doi = {10.1109/ICSE.2017.75},
	shorttitle = {To Type or Not to Type},
	abstract = {{JavaScript} is growing explosively and is now used in large mature projects even outside the web domain. {JavaScript} is also a dynamically typed language for which static type systems, notably Facebook's Flow and Microsoft's {TypeScript}, have been written. What benefits do these static type systems provide? Leveraging {JavaScript} project histories, we select a fixed bug and check out the code just prior to the fix. We manually add type annotations to the buggy code and test whether Flow and {TypeScript} report an error on the buggy code, thereby possibly prompting a developer to fix the bug before its public release. We then report the proportion of bugs on which these type systems reported an error. Evaluating static type systems against public bugs, which have survived testing and review, is conservative: it understates their effectiveness at detecting bugs during private development, not to mention their other benefits such as facilitating code search/completion and serving as documentation. Despite this uneven playing field, our central finding is that both static type systems find an important percentage of public bugs: both Flow 0.30 and {TypeScript} 2.0 successfully detect 15\%!.},
	eventtitle = {2017 {IEEE}/{ACM} 39th International Conference on Software Engineering ({ICSE})},
	pages = {758--769},
	booktitle = {2017 {IEEE}/{ACM} 39th International Conference on Software Engineering ({ICSE})},
	author = {Gao, Zheng and Bird, Christian and Barr, Earl T.},
	date = {2017-05},
	note = {{ISSN}: 1558-1225},
	keywords = {Computer bugs, Documentation, Facebook, Flow, History, {JavaScript}, Measurement uncertainty, mining software repositories, Software, static type systems, Surgery, {TypeScript}},
	file = {IEEE Xplore Abstract Record:/Users/tony.f/Zotero/storage/SLSWHPUM/7985711.html:text/html;IEEE Xplore Full Text PDF:/Users/tony.f/Zotero/storage/N8PJAHXV/Gao et al. - 2017 - To Type or Not to Type Quantifying Detectable Bug.pdf:application/pdf},
}

@inproceedings{gao_type_2017-1,
	title = {To Type or Not to Type: Quantifying Detectable Bugs in {JavaScript}},
	doi = {10.1109/ICSE.2017.75},
	shorttitle = {To Type or Not to Type},
	abstract = {{JavaScript} is growing explosively and is now used in large mature projects even outside the web domain. {JavaScript} is also a dynamically typed language for which static type systems, notably Facebook's Flow and Microsoft's {TypeScript}, have been written. What benefits do these static type systems provide? Leveraging {JavaScript} project histories, we select a fixed bug and check out the code just prior to the fix. We manually add type annotations to the buggy code and test whether Flow and {TypeScript} report an error on the buggy code, thereby possibly prompting a developer to fix the bug before its public release. We then report the proportion of bugs on which these type systems reported an error. Evaluating static type systems against public bugs, which have survived testing and review, is conservative: it understates their effectiveness at detecting bugs during private development, not to mention their other benefits such as facilitating code search/completion and serving as documentation. Despite this uneven playing field, our central finding is that both static type systems find an important percentage of public bugs: both Flow 0.30 and {TypeScript} 2.0 successfully detect 15\%!.},
	eventtitle = {2017 {IEEE}/{ACM} 39th International Conference on Software Engineering ({ICSE})},
	pages = {758--769},
	booktitle = {2017 {IEEE}/{ACM} 39th International Conference on Software Engineering ({ICSE})},
	author = {Gao, Zheng and Bird, Christian and Barr, Earl T.},
	date = {2017-05},
	note = {{ISSN}: 1558-1225},
	keywords = {Computer bugs, Documentation, Facebook, Flow, History, {JavaScript}, Measurement uncertainty, mining software repositories, Software, static type systems, Surgery, {TypeScript}},
	file = {Full Text:/Users/tony.f/Zotero/storage/DV88AQUU/Gao et al. - 2017 - To Type or Not to Type Quantifying Detectable Bug.pdf:application/pdf;IEEE Xplore Abstract Record:/Users/tony.f/Zotero/storage/LGM3MNSZ/7985711.html:text/html},
}

@inproceedings{mayer_empirical_2012,
	location = {New York, {NY}, {USA}},
	title = {An empirical study of the influence of static type systems on the usability of undocumented software},
	isbn = {978-1-4503-1561-6},
	url = {https://doi.org/10.1145/2384616.2384666},
	doi = {10.1145/2384616.2384666},
	series = {{OOPSLA} '12},
	abstract = {Abstract Although the study of static and dynamic type systems plays a major role in research, relatively little is known about the impact of type systems on software development. Perhaps one of the more common arguments for static type systems in languages such as Java or C++ is that they require developers to annotate their code with type names, which is thus claimed to improve the documentation of software. In contrast, one common argument against static type systems is that they decrease flexibility, which may make them harder to use. While these arguments are found in the literature, rigorous empirical evidence is lacking. We report on a controlled experiment where 27 subjects performed programming tasks on an undocumented {API} with a static type system (requiring type annotations) as well as a dynamic type system (which does not). Our results show that for some tasks, programmers had faster completion times using a static type system, while for others, the opposite held. We conduct an exploratory study to try and theorize why.},
	pages = {683--702},
	booktitle = {Proceedings of the {ACM} international conference on Object oriented programming systems languages and applications},
	publisher = {Association for Computing Machinery},
	author = {Mayer, Clemens and Hanenberg, Stefan and Robbes, Romain and Tanter, Éric and Stefik, Andreas},
	urldate = {2022-12-04},
	date = {2012-10-19},
	keywords = {empirical research, programming languages, type systems},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/SL8KC92D/Mayer et al. - 2012 - An empirical study of the influence of static type.pdf:application/pdf},
}

@article{tirronen_understanding_2015,
	title = {Understanding beginners' mistakes with Haskell},
	volume = {25},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/understanding-beginners-mistakes-with-haskell/244DB6807F3BD77E14CE7D627514D6D3},
	doi = {10.1017/S0956796815000179},
	abstract = {This article presents an overview of student difficulties in an introductory functional programming ({FP}) course taught in Haskell. The motivation for this study stems from our belief that many student difficulties can be alleviated by understanding the underlying causes of errors and by modifying the educational approach and, possibly, the teaching language accordingly. We analyze students' exercise submissions and categorize student errors according to compiler error messages and then manually according to the observed underlying cause. Our study complements earlier studies on the topic by applying computer and manual analysis while focusing on providing descriptive statistics of difficulties specific to {FP} languages. We conclude that the majority of student errors, regardless of cause, are reported by three different compiler error messages that are not well understood by students. In addition, syntactic features, such as precedence, the syntax of function application, and deeply nested statements, cause difficulties throughout the course.},
	pages = {e11},
	journaltitle = {Journal of Functional Programming},
	author = {Tirronen, Ville and Uusi-Mäkelä, Samuel and Isomöttönen, Ville},
	urldate = {2022-12-04},
	date = {2015},
	langid = {english},
	note = {Publisher: Cambridge University Press},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/U7MS9SCB/Tirronen et al. - 2015 - Understanding beginners' mistakes with Haskell.pdf:application/pdf;Snapshot:/Users/tony.f/Zotero/storage/TFWL3SXM/244DB6807F3BD77E14CE7D627514D6D3.html:text/html},
}

@inproceedings{schilling_constraint-free_2012,
	location = {Berlin, Heidelberg},
	title = {Constraint-Free Type Error Slicing},
	isbn = {978-3-642-32037-8},
	doi = {10.1007/978-3-642-32037-8_1},
	series = {Lecture Notes in Computer Science},
	abstract = {Type error messages for {ML}-based languages tend to suffer from imprecise error locations – the type checker reports only one of many possible locations of an error. The notion of a type error slice corrects this by reporting all program locations that contribute to a given error (and no more).},
	pages = {1--16},
	booktitle = {Trends in Functional Programming},
	publisher = {Springer},
	author = {Schilling, Thomas},
	editor = {Peña, Ricardo and Page, Rex},
	date = {2012},
	langid = {english},
	keywords = {Error Message, Source Program, Syntactic Category, Type Error, Type Variable},
}

@inproceedings{yang_improved_2000,
	title = {Improved type error reporting},
	booktitle = {In Proceedings of 12th International Workshop on Implementation of Functional Languages},
	publisher = {Citeseer},
	author = {Yang, Jun and Michaelson, Greg and Trinder, Phil and Wells, Joseph Brian},
	date = {2000},
	file = {Yang et al. - 2000 - Improved type error reporting.pdf:/Users/tony.f/Zotero/storage/KCKI7Y6P/Yang et al. - 2000 - Improved type error reporting.pdf:application/pdf},
}

@inproceedings{tsushima_type_2021,
	location = {New York, {NY}, {USA}},
	title = {Type debugging with counter-factual type error messages using an existing type checker},
	isbn = {978-1-4503-7562-7},
	url = {https://doi.org/10.1145/3412932.3412939},
	doi = {10.1145/3412932.3412939},
	series = {{IFL} '19},
	abstract = {The cause of a type error can be very difficult to find for the Hindley-Milner type system. Consequently many solutions have been proposed, but they are hardly used in practice. Here we propose a new solution that provides counter-factual type error messages; these messages state what types specific subexpressions in a program should have (in contrast to the types they actually have) to remove a type error. Such messages are easy-to-understand, because programers are already familiar with them. Furthermore, our solution is easy-to-implement, because it reuses an existing type checker as a subroutine. We transform an ill-typed program into a well-typed program with additional λ-bound variables. The types of these λ-bound variables yield actual and counter-factual type information. That type information plus intended types added as type annotations direct the search of the type debugger.},
	pages = {1--12},
	booktitle = {Proceedings of the 31st Symposium on Implementation and Application of Functional Languages},
	publisher = {Association for Computing Machinery},
	author = {Tsushima, Kanae and Chitil, Olaf and Sharrad, Joanna},
	urldate = {2022-12-02},
	date = {2021-07-15},
	keywords = {hindley-milner type system, {OCaml}},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/NHM2TBSC/Tsushima et al. - 2021 - Type debugging with counter-factual type error mes.pdf:application/pdf},
}

@inproceedings{pavlinovic_practical_2015,
	location = {New York, {NY}, {USA}},
	title = {Practical {SMT}-based type error localization},
	isbn = {978-1-4503-3669-7},
	url = {https://doi.org/10.1145/2784731.2784765},
	doi = {10.1145/2784731.2784765},
	series = {{ICFP} 2015},
	abstract = {Compilers for statically typed functional programming languages are notorious for generating confusing type error messages. When the compiler detects a type error, it typically reports the program location where the type checking failed as the source of the error. Since other error sources are not even considered, the actual root cause is often missed. A more adequate approach is to consider all possible error sources and report the most useful one subject to some usefulness criterion. In our previous work, we showed that this approach can be formulated as an optimization problem related to satisfiability modulo theories ({SMT}). This formulation cleanly separates the heuristic nature of usefulness criteria from the underlying search problem. Unfortunately, algorithms that search for an optimal error source cannot directly use principal types which are crucial for dealing with the exponential-time complexity of the decision problem of polymorphic type checking. In this paper, we present a new algorithm that efficiently finds an optimal error source in a given ill-typed program. Our algorithm uses an improved {SMT} encoding to cope with the high complexity of polymorphic typing by iteratively expanding the typing constraints from which principal types are derived. The algorithm preserves the clean separation between the heuristics and the actual search. We have implemented our algorithm for {OCaml}. In our experimental evaluation, we found that the algorithm reduces the running times for optimal type error localization from minutes to seconds and scales better than previous localization algorithms.},
	pages = {412--423},
	booktitle = {Proceedings of the 20th {ACM} {SIGPLAN} International Conference on Functional Programming},
	publisher = {Association for Computing Machinery},
	author = {Pavlinovic, Zvonimir and King, Tim and Wies, Thomas},
	urldate = {2022-12-02},
	date = {2015-08-29},
	keywords = {Polymorphic Types, Satisfiability Modulo Theories, Type Error Localization},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/DT9YHB5D/Pavlinovic et al. - 2015 - Practical SMT-based type error localization.pdf:application/pdf},
}

@article{tirronen_understanding_2015-1,
	title = {Understanding beginners' mistakes with Haskell},
	volume = {25},
	issn = {0956-7968, 1469-7653},
	doi = {10.1017/S0956796815000179},
	abstract = {This article presents an overview of student difficulties in an introductory functional programming ({FP}) course taught in Haskell. The motivation for this study stems from our belief that many student difficulties can be alleviated by understanding the underlying causes of errors and by modifying the educational approach and, possibly, the teaching language accordingly. We analyze students' exercise submissions and categorize student errors according to compiler error messages and then manually according to the observed underlying cause. Our study complements earlier studies on the topic by applying computer and manual analysis while focusing on providing descriptive statistics of difficulties specific to {FP} languages. We conclude that the majority of student errors, regardless of cause, are reported by three different compiler error messages that are not well understood by students. In addition, syntactic features, such as precedence, the syntax of function application, and deeply nested statements, cause difficulties throughout the course.},
	pages = {e11},
	journaltitle = {Journal of Functional Programming},
	author = {Tirronen, Ville and Uusi-Mäkelä, Samuel and Isomöttönen, Ville},
	urldate = {2022-11-30},
	date = {2015},
	langid = {english},
	note = {Publisher: Cambridge University Press},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/CVGTHT3I/Tirronen et al. - 2015 - Understanding beginners' mistakes with Haskell.pdf:application/pdf;Snapshot:/Users/tony.f/Zotero/storage/PX3IZ8M4/244DB6807F3BD77E14CE7D627514D6D3.html:text/html},
}

@book{jakob_nielsen_usability_1994,
	title = {Usability Engineering},
	publisher = {Morgan Kaufmann},
	author = {{Jakob Nielsen}},
	date = {1994},
}

@online{stackoverflow_stack_2022,
	title = {Stack Overflow Developer Survey 2022},
	url = {https://survey.stackoverflow.co/2022/},
	abstract = {In May 2022 over 70,000 developers told us how they learn and level up, which tools they’re using, and what they want.},
	titleaddon = {Stack Overflow},
	author = {{StackOverflow}},
	urldate = {2022-11-30},
	date = {2022},
	langid = {english},
	file = {Snapshot:/Users/tony.f/Zotero/storage/6JVDBGSQ/2022.html:text/html},
}

@online{github_github_2022,
	title = {{GitHub} Topic: Haskell},
	url = {https://github.com/topics/haskell},
	abstract = {{GitHub} is where people build software. More than 94 million people use {GitHub} to discover, fork, and contribute to over 330 million projects.},
	titleaddon = {{GitHub}},
	author = {{Github}},
	urldate = {2022-12-01},
	date = {2022},
	langid = {english},
	file = {Snapshot:/Users/tony.f/Zotero/storage/I9YMPF7L/haskell.html:text/html},
}

@inproceedings{chen_improving_2022,
	location = {Cham},
	title = {Improving Type Error Reporting for Type Classes},
	isbn = {978-3-030-99461-7},
	doi = {10.1007/978-3-030-99461-7_2},
	series = {Lecture Notes in Computer Science},
	abstract = {Debugging type errors when type inference fails is a challenging problem since there are many different ways to remove the type error, and it’s unclear which way is intended. While numerous approaches have been proposed to more precisely locate the real error causes, most of them do not deal with popular type system extensions, such as type classes. A second problem is that most approaches do not provide enough information for removing the type error or do so for a few error causes only.},
	pages = {19--38},
	booktitle = {Functional and Logic Programming},
	publisher = {Springer International Publishing},
	author = {Chen, Sheng and Noor, Md Rabib},
	editor = {Hanus, Michael and Igarashi, Atsushi},
	date = {2022},
	langid = {english},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/S49WNG7Q/Chen and Noor - 2022 - Improving Type Error Reporting for Type Classes.pdf:application/pdf},
}

@online{openreplay_openreplay_2022,
	title = {{OpenReplay}: Open-Source Session Replay},
	url = {https://openreplay.com/},
	author = {{OpenReplay}},
	urldate = {2022-12-01},
	date = {2022},
}

@online{oracle_generic_2022,
	title = {Generic Methods and Bounded Type Parameters (The Java™ Tutorials {\textgreater} Learning the Java Language {\textgreater} Generics (Updated))},
	url = {https://docs.oracle.com/javase/tutorial/java/generics/boundedTypeParams.html},
	author = {{Oracle}},
	urldate = {2022-12-01},
	date = {2022},
	file = {Generic Methods and Bounded Type Parameters (The Java™ Tutorials > Learning the Java Language > Generics (Updated)):/Users/tony.f/Zotero/storage/N4IGCP5E/boundedTypeParams.html:text/html},
}

@online{bill_wagner_constraints_2022,
	title = {Constraints on type parameters - C\# Programming Guide},
	url = {https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters},
	abstract = {Learn about constraints on type parameters. Constraints tell the compiler what capabilities a type argument must have.},
	author = {{Bill Wagner}},
	urldate = {2022-12-01},
	date = {2022},
	langid = {english},
}

@online{microsoft_documentation_2022,
	title = {Documentation - Generics},
	url = {https://www.typescriptlang.org/docs/handbook/2/generics.html},
	abstract = {Types which take parameters},
	author = {{Microsoft}},
	urldate = {2022-12-01},
	date = {2022},
	langid = {english},
}

@software{ben_gamari_glasgow_2022,
	title = {Glasgow Haskell Compiler},
	url = {https://www.haskell.org/ghc/},
	version = {9.4.7},
	author = {{Ben Gamari}},
	urldate = {2022-12-01},
	date = {2022},
	file = {Home — The Glasgow Haskell Compiler:/Users/tony.f/Zotero/storage/KQPULY88/ghc.html:text/html},
}

@article{mayer_static_2012,
	title = {Static Type Systems (Sometimes) have a Positive Impact on the Usability of Undocumented Software: An Empirical Evaluation},
	abstract = {Static and dynamic type systems (as well as more recently gradual type systems) are an important research topic in programming language design. Although the study of such systems plays a major role in research, relatively little is known about the impact of type systems on software development. Perhaps one of the more common arguments for static type systems is that they require developers to annotate their code with type names, which is thus claimed to improve the documentation of software. In contrast, one common argument against static type systems is that they decrease ﬂexibility, which may make them harder to use. While positions such as these, both for and against static type systems, have been documented in the literature, there is little rigorous empirical evidence for or against either position. In this paper, we introduce a controlled experiment where 27 subjects performed programming tasks on an undocumented {API} with a static type system (which required type annotations) as well as a dynamic type system (which does not). Our results show that for some types of tasks, programmers were afforded faster task completion times using a static type system, while for others, the opposite held. In this work, we document the empirical evidence that led us to this conclusion and conduct an exploratory study to try and theorize why.},
	pages = {20},
	author = {Mayer, Clemens and Robbes, Romain and Tanter, Éric and Steﬁk, Andreas},
	date = {2012},
	langid = {english},
	file = {Mayer et al. - Static Type Systems (Sometimes) have a Positive Im.pdf:/Users/tony.f/Zotero/storage/PR85XC8Y/Mayer et al. - Static Type Systems (Sometimes) have a Positive Im.pdf:application/pdf},
}

@article{jun_explaining_2002,
	title = {Explaining Polymorphic Types},
	volume = {45},
	doi = {10.1093/comjnl/45.4.436},
	abstract = {Polymorphic types in programming languages facilitate code reuse, increase reliability and reduce semantic errors in programs. Hindley-Milner type inference forms a strong basis for checking polymorphic types but is less well suited to explaining them, as it introduces intermediate constructs that relate poorly to a programmer’s understanding of the program. We report an experiment into expert human type explanation and uncover a simple set of rules for human-like explanations. We present a type explanation system based on these rules rather than Hindley-Milner inference. The system uses a new ℋ inference algorithm to annotate types with explanations and is designed to produce succinct, non-repetitive explanations with minimal reference to artefacts of mechanized type inference.},
	pages = {436--452},
	journaltitle = {Comput. J.},
	shortjournal = {Comput. J.},
	author = {Jun, Yang and Michaelson, Greg and Trinder, Phil},
	date = {2002-04-01},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/VEKVMTQD/Jun et al. - 2002 - Explaining Polymorphic Types.pdf:application/pdf},
}

@article{jun_explaining_2002-1,
	title = {Explaining Polymorphic Types},
	volume = {45},
	issn = {1460-2067},
	doi = {10.1093/comjnl/45.4.436},
	abstract = {Polymorphic types in programming languages facilitate code reuse, increase reliability and reduce semantic errors in programs. Hindley–Milner type inference forms a strong basis for checking polymorphic types but is less well suited to explaining them, as it introduces intermediate constructs that relate poorly to a programmer's understanding of the program. We report an experiment into expert human type explanation and uncover a simple set of rules for human-like explanations. We present a type explanation system based on these rules rather than Hindley–Milner inference. The system uses a new \$H\$ inference algorithm to annotate types with explanations and is designed to produce succinct, non-repetitive explanations with minimal reference to artefacts of mechanized type inference.},
	pages = {436--452},
	number = {4},
	journaltitle = {The Computer Journal},
	author = {Jun, Yang and Michaelson, Greg and Trinder, Phil},
	date = {2002-01},
	note = {Conference Name: The Computer Journal},
	file = {IEEE Xplore Abstract Record:/Users/tony.f/Zotero/storage/C8KP3UNV/8129541.html:text/html},
}

@article{chen_counter-factual_2014,
	title = {Counter-factual typing for debugging type errors},
	volume = {49},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/2578855.2535863},
	doi = {10.1145/2578855.2535863},
	abstract = {Changing a program in response to a type error plays an important part in modern software development. However, the generation of good type error messages remains a problem for highly expressive type systems. Existing approaches often suffer from a lack of precision in locating errors and proposing remedies. Specifically, they either fail to locate the source of the type error consistently, or they report too many potential error locations. Moreover, the change suggestions offered are often incorrect. This makes the debugging process tedious and ineffective. We present an approach to the problem of type debugging that is based on generating and filtering a comprehensive set of type-change suggestions. Specifically, we generate all (program-structure-preserving) type changes that can possibly fix the type error. These suggestions will be ranked and presented to the programmer in an iterative fashion. In some cases we also produce suggestions to change the program. In most situations, this strategy delivers the correct change suggestions quickly, and at the same time never misses any rare suggestions. The computation of the potentially huge set of type-change suggestions is efficient since it is based on a variational type inference algorithm that type checks a program with variations only once, efficiently reusing type information for shared parts. We have evaluated our method and compared it with previous approaches. Based on a large set of examples drawn from the literature, we have found that our method outperforms other approaches and provides a viable alternative.},
	pages = {583--594},
	number = {1},
	journaltitle = {{ACM} {SIGPLAN} Notices},
	shortjournal = {{SIGPLAN} Not.},
	author = {Chen, Sheng and Erwig, Martin},
	urldate = {2022-12-01},
	date = {2014-01-08},
	keywords = {change suggestions, choice types, error localization, type error messages, type inference, type-error debugging},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/TURJCNGE/Chen and Erwig - 2014 - Counter-factual typing for debugging type errors.pdf:application/pdf},
}

@inproceedings{hudak_history_2007,
	location = {New York, {NY}, {USA}},
	title = {A history of Haskell: being lazy with class},
	isbn = {978-1-59593-766-7},
	url = {https://doi.org/10.1145/1238844.1238856},
	doi = {10.1145/1238844.1238856},
	series = {{HOPL} {III}},
	shorttitle = {A history of Haskell},
	abstract = {This paper describes the history of Haskell, including its genesis and principles, technical contributions, implementations and tools, and applications and impact.},
	pages = {12--1--12--55},
	booktitle = {Proceedings of the third {ACM} {SIGPLAN} conference on History of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Hudak, Paul and Hughes, John and Peyton Jones, Simon and Wadler, Philip},
	urldate = {2022-11-30},
	date = {2007-06-09},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/Y35DCS9K/Hudak et al. - 2007 - A history of Haskell being lazy with class.pdf:application/pdf},
}

@inproceedings{jbara_how_2015,
	title = {How Programmers Read Regular Code: A Controlled Experiment Using Eye Tracking},
	doi = {10.1109/ICPC.2015.35},
	shorttitle = {How Programmers Read Regular Code},
	abstract = {Regular code, which includes repetitions of the same basic pattern, has been shown to have an effect on code comprehension: a regular function can be just as easy to comprehend as an irregular one with the same functionality, despite being longer and including more control constructs. It has been speculated that this effect is due to leveraging the understanding of the first instances to ease the understanding of repeated instances of the pattern. To verify and quantify this effect, we use eye tracking to measure the time and effort spent reading and understanding regular code. The results are that time and effort invested in the initial code segments are indeed much larger than those spent on the later ones, and the decay in effort can be modeled by an exponential or cubic model. This shows that syntactic code complexity metrics (such as {LOC} and {MCC}) need to be made context-sensitive, e.g. By giving reduced weight to repeated segments according to their place in the sequence.},
	eventtitle = {2015 {IEEE} 23rd International Conference on Program Comprehension},
	pages = {244--254},
	booktitle = {2015 {IEEE} 23rd International Conference on Program Comprehension},
	author = {Jbara, Ahmad and Feitelson, Dror G.},
	date = {2015-05},
	note = {{ISSN}: 1092-8138},
	keywords = {Code complexity metrics, Code regularity, Complexity theory, Controlled experiment, Correlation, Diamonds, Eye tracking, Time measurement, Tracking, Visualization},
	file = {IEEE Xplore Abstract Record:/Users/tony.f/Zotero/storage/I8FHQVAY/7181453.html:text/html},
}

@article{jun_explaining_2002-2,
	title = {Explaining Polymorphic Types},
	volume = {45},
	issn = {1460-2067},
	doi = {10.1093/comjnl/45.4.436},
	abstract = {Polymorphic types in programming languages facilitate code reuse, increase reliability and reduce semantic errors in programs. Hindley–Milner type inference forms a strong basis for checking polymorphic types but is less well suited to explaining them, as it introduces intermediate constructs that relate poorly to a programmer's understanding of the program. We report an experiment into expert human type explanation and uncover a simple set of rules for human-like explanations. We present a type explanation system based on these rules rather than Hindley–Milner inference. The system uses a new \$H\$ inference algorithm to annotate types with explanations and is designed to produce succinct, non-repetitive explanations with minimal reference to artefacts of mechanized type inference.},
	pages = {436--452},
	number = {4},
	journaltitle = {The Computer Journal},
	author = {Jun, Yang and Michaelson, Greg and Trinder, Phil},
	date = {2002-01},
	note = {Conference Name: The Computer Journal},
	file = {IEEE Xplore Abstract Record:/Users/tony.f/Zotero/storage/RK8935AC/8129541.html:text/html},
}

@inproceedings{ko_finding_2009,
	location = {New York, {NY}, {USA}},
	title = {Finding causes of program output with the Java Whyline},
	isbn = {978-1-60558-246-7},
	url = {https://doi.org/10.1145/1518701.1518942},
	doi = {10.1145/1518701.1518942},
	series = {{CHI} '09},
	abstract = {Debugging and diagnostic tools are some of the most important software development tools, but most expect developers choose the right code to inspect. Unfortunately, this rarely occurs. A new tool called the Whyline is described which avoids such speculation by allowing developers to select questions about a program's output. The tool then helps developers work backwards from output to its causes. The prototype, which supports Java programs, was evaluated in an experiment in which participants investigated two real bug reports from an open source project using either the Whyline or a breakpoint debugger. Whyline users were successful about three times as often and about twice as fast compared to the control group, and were extremely positive about the tool's ability to simplify diagnostic tasks in software development work.},
	pages = {1569--1578},
	booktitle = {Proceedings of the {SIGCHI} Conference on Human Factors in Computing Systems},
	publisher = {Association for Computing Machinery},
	author = {Ko, Amy J. and Myers, Brad A.},
	urldate = {2022-11-30},
	date = {2009-04-04},
	keywords = {debugging, instrumentation, slicing, whyline},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/HM3JWRZ7/Ko and Myers - 2009 - Finding causes of program output with the Java Why.pdf:application/pdf},
}

@inproceedings{lerner_searching_2007,
	location = {New York, {NY}, {USA}},
	title = {Searching for type-error messages},
	isbn = {978-1-59593-633-2},
	url = {https://doi.org/10.1145/1250734.1250783},
	doi = {10.1145/1250734.1250783},
	series = {{PLDI} '07},
	abstract = {Advanced type systems often need some form of type inference to reduce the burden of explicit typing, but type inference often leads to poor error messages for ill-typed programs. This work pursues a new approach to constructing compilers and presenting type-error messages in which the type-checker itself does not produce the messages. Instead, it is an oracle for a search procedure that finds similar programs that do type-check. Our two-fold goal is to improve error messages while simplifying compiler construction. Our primary implementation and evaluation is for Caml, a language with full type inference. We also present a prototype for C++ template functions, where type instantiation is implicit. A key extension is making our approach robust even when the program has multiple independent type errors.},
	pages = {425--434},
	booktitle = {Proceedings of the 28th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {Association for Computing Machinery},
	author = {Lerner, Benjamin S. and Flower, Matthew and Grossman, Dan and Chambers, Craig},
	urldate = {2022-11-30},
	date = {2007-06-10},
	keywords = {error messages, objective Caml, seminal, type-checking, type-inference},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/88Z8PFLS/Lerner et al. - 2007 - Searching for type-error messages.pdf:application/pdf},
}

@inproceedings{stuckey_interactive_2003,
	location = {Uppsala, Sweden},
	title = {Interactive type debugging in Haskell},
	isbn = {978-1-58113-758-3},
	url = {http://portal.acm.org/citation.cfm?doid=871895.871903},
	doi = {10.1145/871895.871903},
	eventtitle = {the {ACM} {SIGPLAN} workshop},
	pages = {72--83},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} workshop on Haskell  - Haskell '03},
	publisher = {{ACM} Press},
	author = {Stuckey, Peter J. and Sulzmann, Martin and Wazny, Jeremy},
	urldate = {2022-12-01},
	date = {2003},
	langid = {english},
	file = {Stuckey et al. - 2003 - Interactive type debugging in Haskell.pdf:/Users/tony.f/Zotero/storage/V2Z9NGRQ/Stuckey et al. - 2003 - Interactive type debugging in Haskell.pdf:application/pdf},
}

@article{haack_type_2004,
	title = {Type error slicing in implicitly typed higher-order languages},
	volume = {50},
	issn = {0167-6423},
	url = {https://www.sciencedirect.com/science/article/pii/S016764230400005X},
	doi = {10.1016/j.scico.2004.01.004},
	series = {12th European Symposium on Programming ({ESOP} 2003)},
	abstract = {Previous methods have generally identified the location of a type error as a particular program point or the program subtree rooted at that point. We present a new approach that identifies the location of a type error as a set of program points (a slice) all of which are necessary for the type error. We identify the criteria of completeness and minimality for type error slices. We discuss the advantages of complete and minimal type error slices over previous methods of presenting type errors. We present and prove the correctness of algorithms for finding complete and minimal type error slices for implicitly typed higher-order languages like Standard {ML}.},
	pages = {189--224},
	number = {1},
	journaltitle = {Science of Computer Programming},
	shortjournal = {Science of Computer Programming},
	author = {Haack, Christian and Wells, J. B.},
	urldate = {2022-12-01},
	date = {2004-03-01},
	langid = {english},
	keywords = {Intersection types, Type error location, Type inference},
	file = {Full Text:/Users/tony.f/Zotero/storage/5E6RNCET/Haack and Wells - 2004 - Type error slicing in implicitly typed higher-orde.pdf:application/pdf;ScienceDirect Snapshot:/Users/tony.f/Zotero/storage/V96IFGKJ/S016764230400005X.html:text/html},
}

@online{noauthor_history_nodate,
	title = {A history of Haskell {\textbar} Proceedings of the third {ACM} {SIGPLAN} conference on History of programming languages},
	url = {https://dl.acm.org/doi/10.1145/1238844.1238856},
	urldate = {2022-12-01},
}

@article{chargueraud_improving_2015,
	title = {Improving Type Error Messages in {OCaml}},
	volume = {198},
	issn = {2075-2180},
	url = {http://arxiv.org/abs/1512.01897},
	doi = {10.4204/EPTCS.198.4},
	pages = {80--97},
	journaltitle = {Electronic Proceedings in Theoretical Computer Science},
	shortjournal = {Electron. Proc. Theor. Comput. Sci.},
	author = {Charguéraud, Arthur},
	urldate = {2022-11-30},
	date = {2015-12-05},
	langid = {english},
	file = {Charguéraud - 2015 - Improving Type Error Messages in OCaml.pdf:/Users/tony.f/Zotero/storage/7KEJUBV9/Charguéraud - 2015 - Improving Type Error Messages in OCaml.pdf:application/pdf},
}

@inproceedings{marceau_measuring_2011,
	location = {New York, {NY}, {USA}},
	title = {Measuring the effectiveness of error messages designed for novice programmers},
	isbn = {978-1-4503-0500-6},
	url = {https://doi.org/10.1145/1953163.1953308},
	doi = {10.1145/1953163.1953308},
	series = {{SIGCSE} '11},
	abstract = {Good error messages are critical for novice programmers. Re-cognizing this, the {DrRacket} programming environment provides a series of pedagogically-inspired language subsets with error messages customized to each subset. We apply human-factors research methods to explore the effectiveness of these messages. Unlike existing work in this area, we study messages at a fine-grained level by analyzing the edits students make in response to various classes of errors. We present a rubric (which is not language specific) to evaluate student responses, apply it to a course-worth of student lab work, and describe what we have learned about using the rubric effectively. We also discuss some concrete observations on the effectiveness of these messages.},
	pages = {499--504},
	booktitle = {Proceedings of the 42nd {ACM} technical symposium on Computer science education},
	publisher = {Association for Computing Machinery},
	author = {Marceau, Guillaume and Fisler, Kathi and Krishnamurthi, Shriram},
	urldate = {2022-11-30},
	date = {2011-03-09},
	keywords = {error messages, novice programmers, user-studies},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/LYWM4QJT/Marceau et al. - 2011 - Measuring the effectiveness of error messages desi.pdf:application/pdf},
}

@online{noauthor_stack_nodate,
	title = {Stack Overflow Developer Survey 2022},
	url = {https://survey.stackoverflow.co/2022/?utm_source=social-share&utm_medium=social&utm_campaign=dev-survey-2022},
	abstract = {In May 2022 over 70,000 developers told us how they learn and level up, which tools they’re using, and what they want.},
	titleaddon = {Stack Overflow},
	urldate = {2022-11-30},
	langid = {english},
}

@incollection{chatley_next_2019,
	location = {Cham},
	title = {The Next 7000 Programming Languages},
	isbn = {978-3-319-91908-9},
	url = {https://doi.org/10.1007/978-3-319-91908-9_15},
	series = {Lecture Notes in Computer Science},
	abstract = {Landin’s seminal paper “The next 700 programming languages” considered programming languages prior to 1966 and speculated on the next 700. Half-a-century on, we cast programming languages in a Darwinian ‘tree of life’ and explore languages, their features (genes) and language evolution from the viewpoint of ‘survival of the fittest’.},
	pages = {250--282},
	booktitle = {Computing and Software Science: State of the Art and Perspectives},
	publisher = {Springer International Publishing},
	author = {Chatley, Robert and Donaldson, Alastair and Mycroft, Alan},
	editor = {Steffen, Bernhard and Woeginger, Gerhard},
	urldate = {2022-11-30},
	date = {2019},
	langid = {english},
	doi = {10.1007/978-3-319-91908-9_15},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/56KYG6HT/Chatley et al. - 2019 - The Next 7000 Programming Languages.pdf:application/pdf},
}

@inproceedings{kleinschmager_static_2012,
	title = {Do static type systems improve the maintainability of software systems? An empirical study},
	doi = {10.1109/ICPC.2012.6240483},
	shorttitle = {Do static type systems improve the maintainability of software systems?},
	abstract = {Static type systems play an essential role in contemporary programming languages. Despite their importance, whether static type systems influence human software development capabilities remains an open question. One frequently mentioned argument for static type systems is that they improve the maintainability of software systems - an often used claim for which there is no empirical evidence. This paper describes an experiment which tests whether static type systems improve the maintainability of software systems. The results show rigorous empirical evidence that static type are indeed beneficial to these activities, except for fixing semantic errors.},
	eventtitle = {2012 20th {IEEE} International Conference on Program Comprehension ({ICPC})},
	pages = {153--162},
	booktitle = {2012 20th {IEEE} International Conference on Program Comprehension ({ICPC})},
	author = {Kleinschmager, Sebastian and Robbes, Romain and Stefik, Andreas and Hanenberg, Stefan and Tanter, Eric},
	date = {2012-06},
	note = {{ISSN}: 1092-8138},
	keywords = {Software, Time measurement, Educational institutions, Java, Programming, Semantics},
	file = {IEEE Xplore Abstract Record:/Users/tony.f/Zotero/storage/VQA4IKX9/6240483.html:text/html;Submitted Version:/Users/tony.f/Zotero/storage/UDDAJWWA/Kleinschmager et al. - 2012 - Do static type systems improve the maintainability.pdf:application/pdf},
}

@inproceedings{lerner_searching_2007-1,
	location = {New York, {NY}, {USA}},
	title = {Searching for type-error messages},
	isbn = {978-1-59593-633-2},
	url = {https://doi.org/10.1145/1250734.1250783},
	doi = {10.1145/1250734.1250783},
	series = {{PLDI} '07},
	abstract = {Advanced type systems often need some form of type inference to reduce the burden of explicit typing, but type inference often leads to poor error messages for ill-typed programs. This work pursues a new approach to constructing compilers and presenting type-error messages in which the type-checker itself does not produce the messages. Instead, it is an oracle for a search procedure that finds similar programs that do type-check. Our two-fold goal is to improve error messages while simplifying compiler construction. Our primary implementation and evaluation is for Caml, a language with full type inference. We also present a prototype for C++ template functions, where type instantiation is implicit. A key extension is making our approach robust even when the program has multiple independent type errors.},
	pages = {425--434},
	booktitle = {Proceedings of the 28th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {Association for Computing Machinery},
	author = {Lerner, Benjamin S. and Flower, Matthew and Grossman, Dan and Chambers, Craig},
	urldate = {2022-11-28},
	date = {2007-06-10},
	keywords = {error messages, objective Caml, seminal, type-checking, type-inference},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/H2PRXJYK/Lerner et al. - 2007 - Searching for type-error messages.pdf:application/pdf},
}

@inproceedings{tymchuk_jit_2018,
	location = {Gothenburg Sweden},
	title = {{JIT} feedback: what experienced developers like about static analysis},
	isbn = {978-1-4503-5714-2},
	url = {https://dl.acm.org/doi/10.1145/3196321.3196327},
	doi = {10.1145/3196321.3196327},
	shorttitle = {{JIT} feedback},
	abstract = {Although software developers are usually reluctant to use static analysis to detect issues in their source code, our automatic justin-time static analysis assistant was integrated into an Integrated Development Environment, and was evaluated positively by its users. We conducted interviews to understand the impact of the tool on experienced developers, and how it performs in comparison with other static analyzers.},
	eventtitle = {{ICSE} '18: 40th International Conference on Software Engineering},
	pages = {64--73},
	booktitle = {Proceedings of the 26th Conference on Program Comprehension},
	publisher = {{ACM}},
	author = {Tymchuk, Yuriy and Ghafari, Mohammad and Nierstrasz, Oscar},
	urldate = {2022-11-28},
	date = {2018-05-28},
	langid = {english},
	file = {Tymchuk et al. - 2018 - JIT feedback what experienced developers like abo.pdf:/Users/tony.f/Zotero/storage/UPLMXZNT/Tymchuk et al. - 2018 - JIT feedback what experienced developers like abo.pdf:application/pdf},
}

@inproceedings{peitek_what_2020,
	location = {Seoul Republic of Korea},
	title = {What Drives the Reading Order of Programmers?: An Eye Tracking Study},
	isbn = {978-1-4503-7958-8},
	url = {https://dl.acm.org/doi/10.1145/3387904.3389279},
	doi = {10.1145/3387904.3389279},
	shorttitle = {What Drives the Reading Order of Programmers?},
	abstract = {Background: The way how programmers comprehend source code depends on several factors, including the source code itself and the programmer. Recent studies showed that novice programmers tend to read source code more like natural language text, whereas experts tend to follow the program execution flow. But, it is unknown how the linearity of source code and the comprehension strategy influence programmers’ linearity of reading order.},
	eventtitle = {{ICPC} '20: 28th International Conference on Program Comprehension},
	pages = {342--353},
	booktitle = {Proceedings of the 28th International Conference on Program Comprehension},
	publisher = {{ACM}},
	author = {Peitek, Norman and Siegmund, Janet and Apel, Sven},
	urldate = {2022-11-28},
	date = {2020-07-13},
	langid = {english},
	file = {Peitek et al. - 2020 - What Drives the Reading Order of Programmers An .pdf:/Users/tony.f/Zotero/storage/5P68H8QU/Peitek et al. - 2020 - What Drives the Reading Order of Programmers An .pdf:application/pdf},
}

@inproceedings{chen_empirical_2020,
	location = {New York, {NY}, {USA}},
	title = {An Empirical Study on Dynamic Typing Related Practices in Python Systems},
	isbn = {978-1-4503-7958-8},
	url = {https://doi.org/10.1145/3387904.3389253},
	doi = {10.1145/3387904.3389253},
	series = {{ICPC} '20},
	abstract = {The dynamic typing discipline of Python allows developers to program at a high level of abstraction. However, type related bugs are commonly encountered in Python systems due to the lack of type declaration and static type checking. Especially, the misuse of dynamic typing discipline produces underlying bugs and increases maintenance efforts. In this paper, we introduce six types of dynamic typing related practices in Python programs, which are the common but potentially risky usage of dynamic typing discipline by developers. We also implement a tool named {PYDYPE} to detect them. Based on this tool, we conduct an empirical study on nine real-world Python systems (with the size of more than 460KLOC) to understand dynamic typing related practices. We investigate how widespread the dynamic typing related practices are, why they are introduced into the systems, whether their usage correlates with increased likelihood of bug occurring, and how developers fix dynamic typing related bugs. The results show that: (1) dynamic typing related practices exist inconsistently in different systems and Inconsistent Variable Types is most prevalent; (2) they are introduced into systems mainly during early development phase to promote development efficiency; (3) they have a significant positive correlation with bug occurring; (4) developers tend to add type checks or exception handling to fix dynamic typing related bugs. These results benefit future research in coding convention, language design, bug detection and fixing.},
	pages = {83--93},
	booktitle = {Proceedings of the 28th International Conference on Program Comprehension},
	publisher = {Association for Computing Machinery},
	author = {Chen, Zhifei and Li, Yanhui and Chen, Bihuan and Ma, Wanwangying and Chen, Lin and Xu, Baowen},
	urldate = {2022-11-28},
	date = {2020-09-12},
	keywords = {Python, dynamic typing, empirical study},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/B5GFRWHC/Chen et al. - 2020 - An Empirical Study on Dynamic Typing Related Pract.pdf:application/pdf},
}

@inproceedings{potter_hazel_2020,
	title = {Hazel Tutor: Guiding Novices Through Type-Driven Development Strategies},
	eventtitle = {Human Aspects of Types and Reasoning Assistants},
	pages = {10},
	author = {Potter, Hannah and Omar, Cyrus},
	date = {2020},
	langid = {english},
	file = {Potter and Omar - Hazel Tutor Guiding Novices Through Type-Driven D.pdf:/Users/tony.f/Zotero/storage/NWG4MUL7/Potter and Omar - Hazel Tutor Guiding Novices Through Type-Driven D.pdf:application/pdf},
}

@inproceedings{barik_developers_2017,
	location = {Buenos Aires, Argentina},
	title = {Do developers read compiler error messages?},
	isbn = {978-1-5386-3868-2},
	url = {https://doi.org/10.1109/ICSE.2017.59},
	doi = {10.1109/ICSE.2017.59},
	series = {{ICSE} '17},
	abstract = {In integrated development environments, developers receive compiler error messages through a variety of textual and visual mechanisms, such as popups and wavy red underlines. Although error messages are the primary means of communicating defects to developers, researchers have a limited understanding on how developers actually use these messages to resolve defects. To understand how developers use error messages, we conducted an eye tracking study with 56 participants from undergraduate and graduate software engineering courses at our university. The participants attempted to resolve common, yet problematic defects in a Java code base within the Eclipse development environment. We found that: 1) participants read error messages and the difficulty of reading these messages is comparable to the difficulty of reading source code, 2) difficulty reading error messages significantly predicts participants' task performance, and 3) participants allocate a substantial portion of their total task to reading error messages (13\%--25\%). The results of our study offer empirical justification for the need to improve compiler error messages for developers.},
	pages = {575--585},
	booktitle = {Proceedings of the 39th International Conference on Software Engineering},
	publisher = {{IEEE} Press},
	author = {Barik, Titus and Smith, Justin and Lubick, Kevin and Holmes, Elisabeth and Feng, Jing and Murphy-Hill, Emerson and Parnin, Chris},
	urldate = {2022-11-28},
	date = {2017-05-20},
	keywords = {compiler errors, eye tracking, integrated development environments, programmer comprehension, reading, visual attention},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/QZMS6ZMH/Barik et al. - 2017 - Do developers read compiler error messages.pdf:application/pdf},
}

@inproceedings{prather_novices_2017,
	location = {New York, {NY}, {USA}},
	title = {On Novices' Interaction with Compiler Error Messages: A Human Factors Approach},
	isbn = {978-1-4503-4968-0},
	url = {https://doi.org/10.1145/3105726.3106169},
	doi = {10.1145/3105726.3106169},
	series = {{ICER} '17},
	shorttitle = {On Novices' Interaction with Compiler Error Messages},
	abstract = {The difficulty in understanding compiler error messages can be a major impediment to novice student learning. To alleviate this issue, multiple researchers have run experiments enhancing compiler error messages in automated assessment tools for programming assignments. The conclusions reached by these published experiments appear to be conducting. We examine these experiments and propose five potential reasons for the inconsistent conclusions concerning enhanced compiler error messages: (1) students do not read them, (2) researchers are measuring the wrong thing, (3) the effects are hard to measure, (4) the messages are not properly designed, (5) the messages are properly designed, but students do not understand them in context due to increased cognitive load. We constructed mixed-methods experiments designed to address reasons 1 and 5 with a specific automated assessment tool, Athene, that previously reported inconclusive results. Testing student comprehension of the enhanced compiler error messages outside the context of an automated assessment tool demonstrated their effectiveness over standard compiler error messages. Quantitative results from a 60 minute one-on-one think-aloud study with 31 students did not show substantial increase in student learning outcomes over the control. However, qualitative results from the one-on-one think-aloud study indicated that most students are reading the enhanced compiler error messages and generally make effective changes after encountering them.},
	pages = {74--82},
	booktitle = {Proceedings of the 2017 {ACM} Conference on International Computing Education Research},
	publisher = {Association for Computing Machinery},
	author = {Prather, James and Pettit, Raymond and {McMurry}, Kayla Holcomb and Peters, Alani and Homer, John and Simone, Nevan and Cohen, Maxine},
	urldate = {2022-11-28},
	date = {2017-08-14},
	keywords = {automated assessment tools, {CS}1, education, ethnography, {HCI}, human factors, usability},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/FYLNZ4FY/Prather et al. - 2017 - On Novices' Interaction with Compiler Error Messag.pdf:application/pdf},
}

@misc{leinonen_using_2022,
	title = {Using Large Language Models to Enhance Programming Error Messages},
	url = {http://arxiv.org/abs/2210.11630},
	doi = {10.48550/arXiv.2210.11630},
	abstract = {A key part of learning to program is learning to understand programming error messages. They can be hard to interpret and identifying the cause of errors can be time-consuming. One factor in this challenge is that the messages are typically intended for an audience that already knows how to program, or even for programming environments that then use the information to highlight areas in code. Researchers have been working on making these errors more novice friendly since the 1960s, however progress has been slow. The present work contributes to this stream of research by using large language models to enhance programming error messages with explanations of the errors and suggestions on how to fix the error. Large language models can be used to create useful and novice-friendly enhancements to programming error messages that sometimes surpass the original programming error messages in interpretability and actionability. These results provide further evidence of the benefits of large language models for computing educators, highlighting their use in areas known to be challenging for students. We further discuss the benefits and downsides of large language models and highlight future streams of research for enhancing programming error messages.},
	number = {{arXiv}:2210.11630},
	publisher = {{arXiv}},
	author = {Leinonen, Juho and Hellas, Arto and Sarsa, Sami and Reeves, Brent and Denny, Paul and Prather, James and Becker, Brett A.},
	urldate = {2022-11-28},
	date = {2022-10-20},
	eprinttype = {arxiv},
	eprint = {2210.11630 [cs]},
	keywords = {Computer Science - Human-Computer Interaction, Computer Science - Artificial Intelligence, Computer Science - Computation and Language, Computer Science - Software Engineering},
	file = {arXiv Fulltext PDF:/Users/tony.f/Zotero/storage/AWNXRMLQ/Leinonen et al. - 2022 - Using Large Language Models to Enhance Programming.pdf:application/pdf;arXiv.org Snapshot:/Users/tony.f/Zotero/storage/H5BUETBU/2210.html:text/html},
}

@article{chen_efficient_2020,
	title = {Efficient counter-factual type error debugging},
	volume = {200},
	issn = {0167-6423},
	url = {https://www.sciencedirect.com/science/article/pii/S0167642320301520},
	doi = {10.1016/j.scico.2020.102544},
	abstract = {Providing effective error messages in response to type errors continues to be a challenge in functional programming. Type error messages often point to bogus error locations or lack sufficient information for removing the type error, making error debugging ineffective. Counter-factual typing ({CFT}) addressed this problem by generating comprehensive error messages with each message includes a rich set of information. However, this comes with a cost of huge computations, making it too slow for interactive use. In particular, our recent study shows that programmers usually have to go through multiple iterations of updating and recompiling programs to remove a type error. Interestingly, our study also finds that program updates are minor in each iteration during type error debugging. We exploit this fact and develop {eCFT}, an efficient version of {CFT}, which doesn't recompute all error fixes from scratch for each updated program but only recomputes error fixes that are changed in response to the update. Our key observation is that minor program changes lead to minor error suggestion changes. {eCFT} is based on principal typing, a typing scheme more amenable to reuse previous typing results. We have evaluated our approach and found it is about 12.4× faster than {CFT} in updating error fixes.},
	pages = {102544},
	journaltitle = {Science of Computer Programming},
	shortjournal = {Science of Computer Programming},
	author = {Chen, Sheng and Wu, Baijun},
	urldate = {2022-11-28},
	date = {2020-12-01},
	langid = {english},
	keywords = {Efficient type-error debugging, Principal typing, Variational typing},
	file = {ScienceDirect Full Text PDF:/Users/tony.f/Zotero/storage/YSRLHV7Q/Chen and Wu - 2020 - Efficient counter-factual type error debugging.pdf:application/pdf;ScienceDirect Snapshot:/Users/tony.f/Zotero/storage/RATV7C6T/S0167642320301520.html:text/html},
}

@article{wu_how_2017,
	title = {How type errors were fixed and what students did?},
	volume = {1},
	url = {https://doi.org/10.1145/3133929},
	doi = {10.1145/3133929},
	abstract = {Providing better supports for debugging type errors has been an active research area in the last three decades. Numerous approaches from different perspectives have been developed. Most approaches work well under certain conditions only, for example, when type errors are caused by single leaves and when type annotations are correct. However, the research community is still unaware of which conditions hold in practice and what the real debugging situations look like. We address this problem with a study of 3 program data sets, which were written in different years, using different compilers, and were of diverse sizes. They include more than 55,000 programs, among which more than 2,700 are ill typed. We investigated all the ill-typed programs, and our results indicate that current error debugging support is far from sufficient in practice since only about 35\% of all type errors were caused by single leaves. In addition, type annotations cannot always be trusted in error debuggers since about 30\% of the time type errors were caused by wrong type annotations. Our study also provides many insights about the debugging behaviors of students in functional programming, which could be exploited for developing more effective error debuggers.},
	pages = {105:1--105:27},
	issue = {{OOPSLA}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Wu, Baijun and Chen, Sheng},
	urldate = {2022-11-28},
	date = {2017-10-12},
	keywords = {type inference, empirical study, Type-error debugging},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/2WB5DVYJ/Wu and Chen - 2017 - How type errors were fixed and what students did.pdf:application/pdf},
}

@inproceedings{watson_bluefix_2012,
	location = {Berlin, Heidelberg},
	title = {{BlueFix}: Using Crowd-Sourced Feedback to Support Programming Students in Error Diagnosis and Repair},
	isbn = {978-3-642-33642-3},
	doi = {10.1007/978-3-642-33642-3_25},
	series = {Lecture Notes in Computer Science},
	shorttitle = {{BlueFix}},
	abstract = {Feedback is regarded as one of the most important influences on student learning and motivation. But standard compiler feedback is designed for experts - not novice programming students, who can find it difficult to interpret and understand. In this paper we present {BlueFix}, an online tool currently integrated into the {BlueJ} {IDE} which is designed to assist programming students with error diagnosis and repair. Unlike existing approaches, {BlueFix} proposes a feedback algorithm based upon frameworks combined from the {HCI} and Pedagogical domains, which can provide different students with dynamic levels of support based upon their compilation behaviour. An evaluation revealed that students’ viewed our tool positively and that our methodology could identify appropriate fixes for uncompilable source code with a significantly higher rate of speed and precision over related techniques in the literature.},
	pages = {228--239},
	booktitle = {Advances in Web-Based Learning - {ICWL} 2012},
	publisher = {Springer},
	author = {Watson, Christopher and Li, Frederick W. B. and Godwin, Jamie L.},
	editor = {Popescu, Elvira and Li, Qing and Klamma, Ralf and Leung, Howard and Specht, Marcus},
	date = {2012},
	langid = {english},
	keywords = {Compiler Errors, Crowd Fixes, Feedback, Programming Education},
	file = {Accepted Version:/Users/tony.f/Zotero/storage/XXB27MDH/Watson et al. - 2012 - BlueFix Using Crowd-Sourced Feedback to Support P.pdf:application/pdf},
}

@inproceedings{uchida_c-helper_2016,
	location = {Setubal, {PRT}},
	title = {C-Helper: C Latent-error Static/Heuristic Checker for Novice Programmers},
	isbn = {978-989-758-179-3},
	url = {https://doi.org/10.5220/0005797703210329},
	doi = {10.5220/0005797703210329},
	series = {{CSEDU} 2016},
	shorttitle = {C-Helper},
	abstract = {For better programming language education, it is crucial to make compiler warning messages more understandable for novice programmers. Unfortunately, however, Kojimaâ s research showed warning messages in commercial-level compilers like {GCC} are still difficult to understand, and the commercial-level compilers tend not to emit how to modify programs to correct the problems. Furthermore, we found that they also tend not to handle latent errors. To solve this problem, by using a heuristic approach, we propose a novel C static checker called C-Helper, that aims to emit more direct error messages understandable for novices to correct wrong programs, and also aims to handle latent errors. Our preliminary evaluation shows that C-Helper was positively evaluated, although our heuristic approach increased false-positives.},
	pages = {321--329},
	booktitle = {Proceedings of the 8th International Conference on Computer Supported Education},
	publisher = {{SCITEPRESS} - Science and Technology Publications, Lda},
	author = {Uchida, Kota and Gondow, Katsuhiko},
	urldate = {2022-11-28},
	date = {2016-04-21},
	keywords = {Programming Education, C Static Checker, Compiler Warning Messages, Heuristics, Latent Errors, Novice Programmer.},
	file = {Submitted Version:/Users/tony.f/Zotero/storage/4CP9WV5Z/Uchida and Gondow - 2016 - C-Helper C Latent-error StaticHeuristic Checker .pdf:application/pdf},
}

@inproceedings{hartmann_what_2010,
	location = {New York, {NY}, {USA}},
	title = {What would other programmers do: suggesting solutions to error messages},
	isbn = {978-1-60558-929-9},
	url = {https://doi.org/10.1145/1753326.1753478},
	doi = {10.1145/1753326.1753478},
	series = {{CHI} '10},
	shorttitle = {What would other programmers do},
	abstract = {Interpreting compiler errors and exception messages is challenging for novice programmers. Presenting examples of how other programmers have corrected similar errors may help novices understand and correct such errors. This paper introduces {HelpMeOut}, a social recommender system that aids the debugging of error messages by suggesting solutions that peers have applied in the past. {HelpMeOut} comprises {IDE} instrumentation to collect examples of code changes that fix errors; a central database that stores fix reports from many users; and a suggestion interface that, given an error, queries the database for a list of relevant fixes and presents these to the programmer. We report on implementations of this architecture for two programming languages. An evaluation with novice programmers found that the technique can suggest useful fixes for 47\% of errors after 39 person-hours of programming in an instrumented environment.},
	pages = {1019--1028},
	booktitle = {Proceedings of the {SIGCHI} Conference on Human Factors in Computing Systems},
	publisher = {Association for Computing Machinery},
	author = {Hartmann, Björn and {MacDougall}, Daniel and Brandt, Joel and Klemmer, Scott R.},
	urldate = {2022-11-27},
	date = {2010-04-10},
	keywords = {debugging, recommender systems},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/DZHWAZNI/Hartmann et al. - 2010 - What would other programmers do suggesting soluti.pdf:application/pdf},
}

@book{barik_error_2018,
	title = {Error Messages as Rational Reconstructions},
	publisher = {North Carolina State University},
	author = {Barik, Titus},
	date = {2018},
}

@inproceedings{barik_how_2018,
	title = {How should compilers explain problems to developers?},
	pages = {633--643},
	booktitle = {Proceedings of the 2018 26th {ACM} Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
	author = {Barik, Titus and Ford, Denae and Murphy-Hill, Emerson and Parnin, Chris},
	date = {2018},
	file = {barik_fse18.pdf:/Users/tony.f/Zotero/storage/J76K3M45/barik_fse18.pdf:application/pdf},
}

@online{parnin_here_nodate,
	title = {Here We Go Again: Why Is It Difficult for Developers to Learn Another Programming Language?},
	url = {https://cacm.acm.org/magazines/2022/3/258915-here-we-go-again/fulltext},
	shorttitle = {Here We Go Again},
	abstract = {Our findings demonstrate that interference is a widespread phenomenon, forcing programmers to adopt suboptimal, opportunistic learning strategies.},
	author = {Parnin, Colton Botta, Titus Barik, Chris, Nischal Shrestha},
	urldate = {2022-03-10},
	langid = {english},
	file = {Snapshot:/Users/tony.f/Zotero/storage/WWFG8RAY/fulltext.html:text/html},
}

@article{seidel_learning_2017,
	title = {Learning to blame: localizing novice type errors with data-driven diagnosis},
	volume = {1},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3138818},
	doi = {10.1145/3138818},
	shorttitle = {Learning to blame},
	abstract = {Localizing type errors is challenging in languages with global type inference, as the type checker must make assumptions about what the programmer intended to do. We introduce Nate, a data-driven approach to error localization based on supervised learning. Nate analyzes a large corpus of training data -- pairs of ill-typed programs and their "fixed" versions -- to automatically learn a model of where the error is most likely to be found. Given a new ill-typed program, Nate executes the model to generate a list of potential blame assignments ranked by likelihood. We evaluate Nate by comparing its precision to the state of the art on a set of over 5,000 ill-typed {OCaml} programs drawn from two instances of an introductory programming course. We show that when the top-ranked blame assignment is considered, Nate's data-driven model is able to correctly predict the exact sub-expression that should be changed 72\% of the time, 28 points higher than {OCaml} and 16 points higher than the state-of-the-art {SHErrLoc} tool. Furthermore, Nate's accuracy surpasses 85\% when we consider the top two locations and reaches 91\% if we consider the top three.},
	pages = {1--27},
	issue = {{OOPSLA}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Seidel, Eric L. and Sibghat, Huma and Chaudhuri, Kamalika and Weimer, Westley and Jhala, Ranjit},
	urldate = {2022-03-05},
	date = {2017-10-12},
	langid = {english},
	file = {Seidel et al. - 2017 - Learning to blame localizing novice type errors w.pdf:/Users/tony.f/Zotero/storage/4VDGVFKH/Seidel et al. - 2017 - Learning to blame localizing novice type errors w.pdf:application/pdf},
}

@inproceedings{mciver_seven_1996,
	location = {Dunedin, New Zealand},
	title = {Seven deadly sins of introductory programming language design},
	isbn = {978-0-8186-7379-5},
	url = {http://ieeexplore.ieee.org/document/534015/},
	doi = {10.1109/SEEP.1996.534015},
	abstract = {We discuss seven undesirable features common to many programming languages used to teach first-time programmers, and illustrate typical pedagogical difficulties which stem from them with examples drawn from the programming languages {ABC}, Ada, C, C++, Eiffel, Haskell, {LISP}, Modula 3, Pascal, Prolog, Scheme, and Turing. We propose seven language design (or selection) principles which may reduce the incidence of such undesirable features.},
	eventtitle = {1996 International Conference Software Engineering: Education and Practice},
	pages = {309--316},
	booktitle = {Proceedings 1996 International Conference Software Engineering: Education and Practice},
	publisher = {{IEEE} Comput. Soc. Press},
	author = {{McIver}, L. and Conway, D.},
	urldate = {2021-10-14},
	date = {1996},
	langid = {english},
	file = {McIver and Conway - 1996 - Seven deadly sins of introductory programming lang.pdf:/Users/tony.f/Zotero/storage/EBT72IY4/SevenDeadlySins.pdf:application/pdf},
}

@article{coblenz_does_2021,
	title = {Does the Bronze Garbage Collector Make Rust Easier to Use? A Controlled Experiment},
	url = {http://arxiv.org/abs/2110.01098},
	shorttitle = {Does the Bronze Garbage Collector Make Rust Easier to Use?},
	abstract = {Rust is a general-purpose programming language that is both typeand memory-safe. Rust does not use a garbage collector, but rather achieves these properties through a sophisticated, but complex, type system. Doing so makes Rust very efficient, but makes Rust relatively hard to learn and use. We designed Bronze, an optional, library-based garbage collector for Rust. To see whether Bronze could make Rust more usable, we conducted a randomized controlled trial with volunteers from a 633-person class, collecting data from 428 students in total. We found that for a task that required managing complex aliasing, Bronze users were more likely to complete the task in the time available, and those who did so required only about a third as much time (4 hours vs. 12 hours). We found no significant difference in total time, even though Bronze users re-did the task without Bronze afterward. Surveys indicated that ownership, borrowing, and lifetimes were primary causes of the challenges that users faced when using Rust.},
	journaltitle = {{arXiv}:2110.01098 [cs]},
	author = {Coblenz, Michael and Mazurek, Michelle and Hicks, Michael},
	urldate = {2021-10-05},
	date = {2021-10-03},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {2110.01098},
	keywords = {Computer Science - Programming Languages, Computer Science - Software Engineering, D.1.0, D.2.3},
	file = {Coblenz et al. - 2021 - Does the Bronze Garbage Collector Make Rust Easier.pdf:/Users/tony.f/Zotero/storage/MN8KDPUP/Coblenz et al. - 2021 - Does the Bronze Garbage Collector Make Rust Easier.pdf:application/pdf},
}

@article{fruhwirth_theory_1998,
	title = {Theory and practice of constraint handling rules},
	volume = {37},
	issn = {0743-1066},
	url = {https://www.sciencedirect.com/science/article/pii/S0743106698100055},
	doi = {10.1016/S0743-1066(98)10005-5},
	abstract = {Constraint Handling Rules ({CHR}) are our proposal to allow more flexibility and application-oriented customization of constraint systems. {CHR} are a declarative language extension especially designed for writing user-defined constraints. {CHR} are essentially a committed-choice language consisting of multi-headed guarded rules that rewrite constraints into simpler ones until they are solved. In this broad survey we aim at covering all aspects of {CHR} as they currently present themselves. Going from theory to practice, we will define syntax and semantics for {CHR}, introduce an important decidable property, confluence, of {CHR} programs and define a tight integration of {CHR} with constraint logic programming languages. This survey then describes implementations of the language before we review several constraint solvers – both traditional and nonstandard ones – written in the {CHR} language. Finally we introduce two innovative applications that benefited from using {CHR}.},
	pages = {95--138},
	number = {1},
	journaltitle = {The Journal of Logic Programming},
	shortjournal = {The Journal of Logic Programming},
	author = {Frühwirth, Thom},
	urldate = {2021-10-01},
	date = {1998-10-01},
	langid = {english},
	file = {ScienceDirect Snapshot:/Users/tony.f/Zotero/storage/WL8Z3HUS/S0743106698100055.html:text/html},
}

@online{noauthor_top_nodate,
	title = {Top Programming Languages 2021},
	url = {https://spectrum.ieee.org/top-programming-languages/},
	abstract = {Is Python still at the top? See this year's Top Programming Languages},
	titleaddon = {{IEEE} Spectrum},
	urldate = {2021-09-30},
	langid = {english},
	file = {Snapshot:/Users/tony.f/Zotero/storage/CH759CDC/top-programming-languages.html:text/html},
}

@article{becker_exploration_nodate,
	title = {An Exploration Of The Effects Of Enhanced Compiler Error Messages For Computer Programming Novices},
	pages = {130},
	author = {Becker, Brett A},
	langid = {english},
	file = {Becker - An Exploration Of The Effects Of Enhanced Compiler.pdf:/Users/tony.f/Zotero/storage/PXS6AU9X/Becker - An Exploration Of The Effects Of Enhanced Compiler.pdf:application/pdf},
}

@inproceedings{becker_towards_2021,
	location = {Virtual {SA} Australia},
	title = {Towards Assessing the Readability of Programming Error Messages},
	isbn = {978-1-4503-8976-1},
	url = {https://dl.acm.org/doi/10.1145/3441636.3442320},
	doi = {10.1145/3441636.3442320},
	abstract = {Programming error messages have proven to be notoriously problematic for novices who are learning to program. Although recent efforts have focused on improving message wording, these have been criticized for attempting to improve usability without first understanding and addressing readability. To date, there has been no research dedicated to the readability of programming error messages and how this could be assessed. In this paper we examine human-based assessments of programming error message readability and make two important contributions. First, we conduct an experiment using the top twenty most-frequent error messages in three popular programming languages (Python, Java, and C), revealing that human notions of readability are highly subjective and dependent on both programming experience and language familiarity. Both novices and experts agreed more about which messages are more readable, but disagreed more about which messages are not readable. Second, we leverage the data from this experiment to uncover several key factors that seem to affect message readability: message length, message tone, and use of jargon. We discuss how these factors can help guide future efforts to design a readability metric for programming error messages.},
	eventtitle = {{ACE} '21: Australasian Computing Education Conference},
	pages = {181--188},
	booktitle = {Australasian Computing Education Conference},
	publisher = {{ACM}},
	author = {Becker, Brett A. and Denny, Paul and Prather, James and Pettit, Raymond and Nix, Robert and Mooney, Catherine},
	urldate = {2021-09-29},
	date = {2021-02-02},
	langid = {english},
	file = {Becker et al. - 2021 - Towards Assessing the Readability of Programming E.pdf:/Users/tony.f/Zotero/storage/GGJCKYSL/Becker et al. - 2021 - Towards Assessing the Readability of Programming E.pdf:application/pdf},
}

@inproceedings{marceau_measuring_2011-1,
	location = {New York, {NY}, {USA}},
	title = {Measuring the effectiveness of error messages designed for novice programmers},
	isbn = {978-1-4503-0500-6},
	url = {https://doi.org/10.1145/1953163.1953308},
	doi = {10.1145/1953163.1953308},
	series = {{SIGCSE} '11},
	abstract = {Good error messages are critical for novice programmers. Re-cognizing this, the {DrRacket} programming environment provides a series of pedagogically-inspired language subsets with error messages customized to each subset. We apply human-factors research methods to explore the effectiveness of these messages. Unlike existing work in this area, we study messages at a fine-grained level by analyzing the edits students make in response to various classes of errors. We present a rubric (which is not language specific) to evaluate student responses, apply it to a course-worth of student lab work, and describe what we have learned about using the rubric effectively. We also discuss some concrete observations on the effectiveness of these messages.},
	pages = {499--504},
	booktitle = {Proceedings of the 42nd {ACM} technical symposium on Computer science education},
	publisher = {Association for Computing Machinery},
	author = {Marceau, Guillaume and Fisler, Kathi and Krishnamurthi, Shriram},
	urldate = {2021-09-28},
	date = {2011-03-09},
	keywords = {error messages, novice programmers, user-studies},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/GV8UJF73/Marceau et al. - 2011 - Measuring the effectiveness of error messages desi.pdf:application/pdf},
}

@inproceedings{denny_designing_2021,
	location = {New York, {NY}, {USA}},
	title = {On Designing Programming Error Messages for Novices: Readability and its Constituent Factors},
	isbn = {978-1-4503-8096-6},
	url = {https://doi.org/10.1145/3411764.3445696},
	doi = {10.1145/3411764.3445696},
	series = {{CHI} '21},
	shorttitle = {On Designing Programming Error Messages for Novices},
	abstract = {Programming error messages play an important role in learning to program. The cycle of program input and error message response completes a loop between the programmer and the compiler/interpreter and is a fundamental interaction between human and computer. However, error messages are notoriously problematic, especially for novices. Despite numerous guidelines citing the importance of message readability, there is little empirical research dedicated to understanding and assessing it. We report three related experiments investigating factors that influence programming error message readability. In the first two experiments we identify possible factors, and in the third we ask novice programmers to rate messages using scales derived from these factors. We find evidence that several key factors significantly affect message readability: message length, jargon use, sentence structure, and vocabulary. This provides novel empirical support for previously untested long-standing guidelines on message design, and informs future efforts to create readability metrics for programming error messages.},
	pages = {1--15},
	booktitle = {Proceedings of the 2021 {CHI} Conference on Human Factors in Computing Systems},
	publisher = {Association for Computing Machinery},
	author = {Denny, Paul and Prather, James and Becker, Brett A. and Mooney, Catherine and Homer, John and Albrecht, Zachary C and Powell, Garrett B.},
	urldate = {2021-09-28},
	date = {2021-05-06},
	keywords = {novice programmers, {CS}1, {HCI}, compiler design and implementation, compiler error messages, human computer interaction, introductory programming, programming error messages, readability, students},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/IZMUQM5M/Denny et al. - 2021 - On Designing Programming Error Messages for Novice.pdf:application/pdf},
}

@article{hage_solved_2020-1,
	title = {Solved and Open Problems in Type Error Diagnosis},
	abstract = {The purpose of this paper is to present a number of directions for future research in type error diagnosis. To be able to position these open problems, we ﬁrst discuss accomplishments in the ﬁeld without trying to be exhaustive.},
	pages = {13},
	author = {Hage, Jurriaan},
	date = {2020},
	langid = {english},
	file = {Hage - Solved and Open Problems in Type Error Diagnosis.pdf:/Users/tony.f/Zotero/storage/57IM6FAP/Hage - Solved and Open Problems in Type Error Diagnosis.pdf:application/pdf},
}

@video{acm_sigplan_integrating_2020,
	title = {Integrating User-Centered Methods into Programming Language Design},
	url = {https://www.youtube.com/watch?v=-m34gNVVpFQ},
	abstract = {https://icfp20.sigplan.org/details/ic...



Many programming languages serve as interfaces that people can use to write programs. In our research, we have adapted many of the techniques of human-computer interaction in order to provide insight into the usability of programming language designs. These adaptations allow us to design languages that take the target users into account, as well as to assess the usability of the resulting languages.

In this tutorial, we will show how to integrate user-centered techniques into the design process of programming languages. This approach allows you, a language designer, to gather data from programmers and software engineers while designing your language in order to make your languages more usable. Then, you can conduct user studies to evaluate how effective your design is with users.

We will teach participants techniques for obtaining useful usability data from participants:

    Interviews and surveys
    Natural programming
    Usability studies, e.g. Wizard of Oz and think-aloud
    Comparative studies (A vs. B)

We will also address important practical considerations, such as participant recruitment and ethics. Part of the tutorial will be lecture-style. However, we hope that you bring your own language design questions to the tutorial. We will set aside time for you to work with us and other participants to practice developing studies about the questions that interest you most.

In order to help us customize the tutorial for you, we would appreciate it if you could pre-register.},
	author = {{ACM SIGPLAN}},
	urldate = {2021-09-28},
	date = {2020-09-13},
}

@incollection{justin_lubin_how_2021,
	location = {New York, {NY}, {USA}},
	title = {How Statically-Typed Functional Programmers Author Code},
	isbn = {978-1-4503-8095-9},
	url = {https://doi.org/10.1145/3411763.3451515},
	abstract = {How working statically-typed functional programmers author code is largely understudied. And yet, a better understanding of developer practices could pave the way for the design of more useful and usable tooling, more ergonomic languages, and more effective on-ramps into programming communities. The goal of this work is to address this knowledge gap: to better understand the high-level authoring patterns that statically-typed functional programmers engage in. I did a grounded theory analysis of thirteen programming sessions of practicing functional programmers, eight of which also included a semi-structured interview. The theory I developed gives insight into how the specific affordances of statically-typed functional programming affect domain modeling, type construction, focusing techniques, exploratory strategies, mental models, and expressions of intent. The success of this approach in revealing program authorship patterns suggests that the same methodology could be used to study other understudied programmer audiences.},
	pages = {1--6},
	number = {484},
	booktitle = {Extended Abstracts of the 2021 {CHI} Conference on Human Factors in Computing Systems},
	publisher = {Association for Computing Machinery},
	author = {{Justin Lubin}},
	urldate = {2021-09-20},
	date = {2021-05-08},
	keywords = {functional programming, grounded theory, interviews, need-finding, Static types},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/U2C8BKCG/Lubin - 2021 - How Statically-Typed Functional Programmers Author.pdf:application/pdf},
}

@online{sussman_constraints_nodate,
	title = {Constraints: A Language for Expressing Almost-Hierarchical Descriptions},
	url = {https://dspace.mit.edu/bitstream/handle/1721.1/6312/AIM-502a.pdf},
	abstract = {We present an interactive system organized around networks of constraints rather than the programs which manipulate them. We describe a language of hierarchical constraint networks. We describe one method of deriving useful analysis is used to spot and track down inconsistent subsets of a constraint set. Propagation of constraints is most flexible and useful when coupled with the ability to perform symbolic manipulations and algebraic expressions. Such manipulations are in turn best expressed as alterations or augmentations of the constraint network.

Almost-Hierarchical Constraint Networks can be constructed to present multiple viewpoints used by engineers in the synthesis and analysis of electrical networks. These multiple viewpoints are used in terminal equivalence and power arguments to reduce the apparent synergy in circuit so that it can be attacked algebraically.

This report describes research done at the Artificial Intelligence Laboratory of Massachusetts Institute of Technology. This work was supported in part by the National Science Foundation under Grant {MCS}77-04828 and in part by Air Force Office of Scientific Research Grant {AFOSR}-78-3593.},
	author = {Sussman, Gerald Jay and Steele, Guy Lewis {JR}.},
	urldate = {2021-06-20},
	file = {AIM-502a.pdf:/Users/tony.f/Zotero/storage/NL48ECCR/AIM-502a.pdf:application/pdf},
}

@inproceedings{barik_developers_2017-1,
	title = {Do Developers Read Compiler Error Messages?},
	doi = {10.1109/ICSE.2017.59},
	abstract = {In integrated development environments, developers receive compiler error messages through a variety of textual and visual mechanisms, such as popups and wavy red underlines. Although error messages are the primary means of communicating defects to developers, researchers have a limited understanding on how developers actually use these messages to resolve defects. To understand how developers use error messages, we conducted an eye tracking study with 56 participants from undergraduate and graduate software engineering courses at our university. The participants attempted to resolve common, yet problematic defects in a Java code base within the Eclipse development environment. We found that: 1) participants read error messages and the difficulty of reading these messages is comparable to the difficulty of reading source code, 2) difficulty reading error messages significantly predicts participants' task performance, and 3) participants allocate a substantial portion of their total task to reading error messages (13\%-25\%). The results of our study offer empirical justification for the need to improve compiler error messages for developers.},
	eventtitle = {2017 {IEEE}/{ACM} 39th International Conference on Software Engineering ({ICSE})},
	pages = {575--585},
	booktitle = {2017 {IEEE}/{ACM} 39th International Conference on Software Engineering ({ICSE})},
	author = {Barik, Titus and Smith, Justin and Lubick, Kevin and Holmes, Elisabeth and Feng, Jing and Murphy-Hill, Emerson and Parnin, Chris},
	date = {2017-05},
	note = {{ISSN}: 1558-1225},
	keywords = {Visualization, Java, compiler errors, eye tracking, integrated development environments, programmer comprehension, reading, visual attention, Gaze tracking, Google, Libraries, Navigation, Software engineering},
	file = {IEEE Xplore Abstract Record:/Users/tony.f/Zotero/storage/CUTFEKC9/7985695.html:text/html},
}

@article{fruhwirth_constraint_nodate,
	title = {Constraint Handling Rules?},
	abstract = {We are investigating the use of a class of logical formulas to dene constraint theories and implement constraint solvers at the same time. The representation of constraint evaluation in a declarative formalism greatly facilitates the prototyping, extension, specialization and combination of constraint solvers. In our approach, constraint evaluation is speci ed using multiheaded guarded clauses called constraint handling rules ({CHRs}). {CHRs} de ne determinate conditional rewrite systems that express how conjunctions of constraints propagate and simplify.},
	pages = {18},
	author = {Fruhwirth, Thom},
	langid = {english},
	file = {Fruhwirth - Constraint Handling Rules.pdf:/Users/tony.f/Zotero/storage/78LE4VCB/Fruhwirth - Constraint Handling Rules.pdf:application/pdf},
}

@article{sulir_visual_2018,
	title = {Visual augmentation of source code editors: A systematic mapping study},
	volume = {49},
	issn = {1045-926X},
	url = {https://www.sciencedirect.com/science/article/pii/S1045926X18301861},
	doi = {10.1016/j.jvlc.2018.10.001},
	shorttitle = {Visual augmentation of source code editors},
	abstract = {Source code written in textual programming languages is typically edited in integrated development environments ({IDEs}) or specialized code editors. These tools often display various visual items, such as icons, color highlights or more advanced graphical overlays directly in the main editable source code view. We call such visualizations source code editor augmentation. In this paper, we present a first systematic mapping study of source code editor augmentation tools and approaches. We manually reviewed the metadata of 5553 articles published during the last twenty years in two phases – keyword search and references search. The result is a list of 103 relevant articles and a taxonomy of source code editor augmentation tools with seven dimensions, which we used to categorize the resulting list of the surveyed articles. We also provide the definition of the term source code editor augmentation, along with a brief overview of historical development and augmentations available in current industrial {IDEs}.},
	pages = {46--59},
	journaltitle = {Journal of Visual Languages \& Computing},
	shortjournal = {Journal of Visual Languages \& Computing},
	author = {Sulír, Matúš and Bačíková, Michaela and Chodarev, Sergej and Porubän, Jaroslav},
	urldate = {2021-05-24},
	date = {2018-12-01},
	langid = {english},
	keywords = {In situ visualization, Integrated development environment ({IDE}), Source code editor augmentation, Survey, Systematic review},
	file = {ScienceDirect Snapshot:/Users/tony.f/Zotero/storage/MK89WTS3/S1045926X18301861.html:text/html;Submitted Version:/Users/tony.f/Zotero/storage/7KXHT69D/Sulír et al. - 2018 - Visual augmentation of source code editors A syst.pdf:application/pdf},
}

@inproceedings{kang_omnicode_2017,
	location = {Québec City {QC} Canada},
	title = {Omnicode: A Novice-Oriented Live Programming Environment with Always-On Run-Time Value Visualizations},
	isbn = {978-1-4503-4981-9},
	url = {https://dl.acm.org/doi/10.1145/3126594.3126632},
	doi = {10.1145/3126594.3126632},
	shorttitle = {Omnicode},
	abstract = {Visualizations of run-time program state help novices form proper mental models and debug their code. We push this technique to the extreme by posing the following question: What if a live programming environment for an imperative language always displays the entire history of all run-time values for all program variables all the time? To explore this question, we built a prototype live {IDE} called Omnicode (“Omniscient Code”) that continually runs the user’s Python code and uses a scatterplot matrix to visualize the entire history of all of its numerical values, along with meaningful numbers derived from other data types. To ﬁlter the visualizations and hone in on speciﬁc points of interest, the user can brush and link over the scatterplots or select portions of code. They can also zoom in to view detailed stack and heap visualizations at each execution step. An exploratory study on 10 novice programmers discovered that they found Omnicode to be useful for debugging, forming mental models, explaining their code to others, and discovering moments of serendipity that would not have been likely within an ordinary {IDE}.},
	eventtitle = {{UIST} '17: The 30th Annual {ACM} Symposium on User Interface Software and Technology},
	pages = {737--745},
	booktitle = {Proceedings of the 30th Annual {ACM} Symposium on User Interface Software and Technology},
	publisher = {{ACM}},
	author = {Kang, Hyeonsu and Guo, Philip J.},
	urldate = {2021-05-22},
	date = {2017-10-20},
	langid = {english},
	file = {Kang and Guo - 2017 - Omnicode A Novice-Oriented Live Programming Envir.pdf:/Users/tony.f/Zotero/storage/55N7A9DE/Kang and Guo - 2017 - Omnicode A Novice-Oriented Live Programming Envir.pdf:application/pdf},
}

@inproceedings{fix_mental_1993,
	location = {Amsterdam, The Netherlands},
	title = {Mental representations of programs by novices and experts},
	isbn = {978-0-89791-575-5},
	url = {http://portal.acm.org/citation.cfm?doid=169059.169088},
	doi = {10.1145/169059.169088},
	abstract = {This paper presents five abstract characteristics of the mental representation of computer programs hierarchical structure, explicit mapping of code to goals, foundation on recognition of recurring patterns, connection of knowledge, and grounding in the program text. An experiment is reported in which expert and novice programmers studied a Pascal program for comprehension and then answered a series of questions about it designed to show these characteristics if they existed in the mental representations formed. Evidence for all of the abstract characteristics was found in the mental representations of expert programmers. Novices’ representations generally lacked the characteristics, but there was evidence that they had the beginnings, although poorly developed, of such characteristics.},
	eventtitle = {the {SIGCHI} conference},
	pages = {74--79},
	booktitle = {Proceedings of the {SIGCHI} conference on Human factors in computing systems  - {CHI} '93},
	publisher = {{ACM} Press},
	author = {Fix, Vikki and Wiedenbeck, Susan and Scholtz, Jean},
	urldate = {2021-05-21},
	date = {1993},
	langid = {english},
	file = {Fix et al. - 1993 - Mental representations of programs by novices and .pdf:/Users/tony.f/Zotero/storage/F7QJ4ZPQ/Fix et al. - 1993 - Mental representations of programs by novices and .pdf:application/pdf},
}

@inproceedings{barik_how_2016,
	location = {Seattle {WA} {USA}},
	title = {How should static analysis tools explain anomalies to developers?},
	isbn = {978-1-4503-4218-6},
	url = {https://dl.acm.org/doi/10.1145/2950290.2983968},
	doi = {10.1145/2950290.2983968},
	abstract = {Despite the advanced static analysis tools available within modern integrated development environments ({IDEs}), the error messages these tools produce remain perplexing for developers to comprehend. This research postulates that tools can computationally expose their internal reasoning processes to generate assistive error explanations that more closely align with how developers explain errors to themselves.},
	eventtitle = {{FSE}'16: 24nd {ACM} {SIGSOFT} International Symposium on the Foundations of Software Engineering},
	pages = {1118--1120},
	booktitle = {Proceedings of the 2016 24th {ACM} {SIGSOFT} International Symposium on Foundations of Software Engineering},
	publisher = {{ACM}},
	author = {Barik, Titus},
	urldate = {2021-05-21},
	date = {2016-11},
	langid = {english},
	file = {Barik - 2016 - How should static analysis tools explain anomalies.pdf:/Users/tony.f/Zotero/storage/WRA3TLS5/Barik - 2016 - How should static analysis tools explain anomalies.pdf:application/pdf},
}

@article{ahmadzadeh_analysis_2005,
	title = {An analysis of patterns of debugging among novice computer science students},
	volume = {37},
	issn = {0097-8418},
	url = {https://dl.acm.org/doi/10.1145/1151954.1067472},
	doi = {10.1145/1151954.1067472},
	abstract = {The process by which students learn to program is a major issue in computer science educational research. Programming is a fundamental part of the computer science curriculum, but one which is often problematic. It seems to be difficult to find an effective method of teaching that is suitable for all students. In this research we tried to gain insights into ways of improving our teaching by a careful examination of students’ mistakes. The compiler errors that were generated by their programs together with the pattern that was observed in their debugging activities formed the basis of this research. We discovered that many students with a good understanding of programming do not acquire the skills to debug programs effectively, and this is a major impediment to their producing working code of any complexity. Skill at debugging seems to increase a programmer’s confidence and we suggest that more emphasis be placed on debugging skills in the teaching of programming.},
	pages = {84--88},
	number = {3},
	journaltitle = {{ACM} {SIGCSE} Bulletin},
	shortjournal = {{SIGCSE} Bull.},
	author = {Ahmadzadeh, Marzieh and Elliman, Dave and Higgins, Colin},
	urldate = {2021-05-21},
	date = {2005-09},
	langid = {english},
	file = {Ahmadzadeh et al. - 2005 - An analysis of patterns of debugging among novice .pdf:/Users/tony.f/Zotero/storage/YYEVWI84/Ahmadzadeh et al. - 2005 - An analysis of patterns of debugging among novice .pdf:application/pdf},
}

@inproceedings{becker_effective_2016,
	location = {Memphis Tennessee {USA}},
	title = {An Effective Approach to Enhancing Compiler Error Messages},
	isbn = {978-1-4503-3685-7},
	url = {https://dl.acm.org/doi/10.1145/2839509.2844584},
	doi = {10.1145/2839509.2844584},
	abstract = {One of the many challenges novice programmers face from the time they write their ﬁrst program is inadequate compiler error messages. These messages report details on errors the programmer has made and are the only feedback the programmer gets from the compiler. For students they play a particularly essential role as students often have little experience to draw upon, leaving compiler error messages as their primary guidance on error correction. However these messages are frequently inadequate, presenting a barrier to progress and are often a source of discouragement. We have designed and implemented an editor that provides enhanced compiler error messages and conducted a controlled empirical study with {CS}1 students learning Java. We ﬁnd a reduced frequency of overall errors and errors per student. We also identify eight frequent compiler error messages for which enhancement has a statistically signiﬁcant eﬀect. Finally we ﬁnd a reduced number of repeated errors. These ﬁndings indicate fewer students struggling with compiler error messages.},
	eventtitle = {{SIGCSE} '16: The 47th {ACM} Technical Symposium on Computing Science Education},
	pages = {126--131},
	booktitle = {Proceedings of the 47th {ACM} Technical Symposium on Computing Science Education},
	publisher = {{ACM}},
	author = {Becker, Brett A.},
	urldate = {2021-05-21},
	date = {2016-02-17},
	langid = {english},
	file = {Becker - 2016 - An Effective Approach to Enhancing Compiler Error .pdf:/Users/tony.f/Zotero/storage/YS373YTK/Becker - 2016 - An Effective Approach to Enhancing Compiler Error .pdf:application/pdf},
}

@inproceedings{becker_compiler_2019,
	location = {Aberdeen Scotland Uk},
	title = {Compiler Error Messages Considered Unhelpful: The Landscape of Text-Based Programming Error Message Research},
	isbn = {978-1-4503-7567-2},
	url = {https://dl.acm.org/doi/10.1145/3344429.3372508},
	doi = {10.1145/3344429.3372508},
	shorttitle = {Compiler Error Messages Considered Unhelpful},
	abstract = {Diagnostic messages generated by compilers and interpreters such as syntax error messages have been researched for over half of a century. Unfortunately, these messages which include error, warning, and run-time messages, present substantial difficulty and could be more effective, particularly for novices. Recent years have seen an increased number of papers in the area including studies on the effectiveness of these messages, improving or enhancing them, and their usefulness as a part of programming process data that can be used to predict student performance, track student progress, and tailor learning plans. Despite this increased interest, the long history of literature is quite scattered and has not been brought together in any digestible form.},
	eventtitle = {{ITiCSE} '19: Innovation and Technology in Computer Science Education},
	pages = {177--210},
	booktitle = {Proceedings of the Working Group Reports on Innovation and Technology in Computer Science Education},
	publisher = {{ACM}},
	author = {Becker, Brett A. and Denny, Paul and Pettit, Raymond and Bouchard, Durell and Bouvier, Dennis J. and Harrington, Brian and Kamil, Amir and Karkare, Amey and {McDonald}, Chris and Osera, Peter-Michael and Pearce, Janice L. and Prather, James},
	urldate = {2021-05-21},
	date = {2019-12-18},
	langid = {english},
	file = {becker2019compiler.pdf:/Users/tony.f/Zotero/storage/M6IBPVS7/becker2019compiler.pdf:application/pdf},
}

@incollection{hutchison_programming_2005,
	location = {Berlin, Heidelberg},
	title = {Programming with Arrows},
	volume = {3622},
	isbn = {978-3-540-28540-3 978-3-540-31872-9},
	url = {http://link.springer.com/10.1007/11546382_2},
	pages = {73--129},
	booktitle = {Advanced Functional Programming},
	publisher = {Springer Berlin Heidelberg},
	author = {Hughes, John},
	editor = {Vene, Varmo and Uustalu, Tarmo},
	editorb = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard},
	editorbtype = {redactor},
	urldate = {2021-04-28},
	date = {2005},
	langid = {english},
	doi = {10.1007/11546382_2},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Hughes - 2005 - Programming with Arrows.pdf:/Users/tony.f/Zotero/storage/T5U4VVBJ/Hughes - 2005 - Programming with Arrows.pdf:application/pdf},
}

@inproceedings{rak-amnouykit_python_2020,
	location = {Virtual {USA}},
	title = {Python 3 types in the wild: a tale of two type systems},
	isbn = {978-1-4503-8175-8},
	url = {https://dl.acm.org/doi/10.1145/3426422.3426981},
	doi = {10.1145/3426422.3426981},
	shorttitle = {Python 3 types in the wild},
	abstract = {Python 3 is a highly dynamic language, but it has introduced a syntax for expressing types with {PEP}484. This paper explores how developers use these type annotations, the type system semantics provided by type checking and inference tools, and the performance of these tools. We evaluate the types and tools on a corpus of public {GitHub} repositories. We review {MyPy} and {PyType}, two canonical static type checking and inference tools, and their distinct approaches to type analysis. We then address three research questions: (i) How often and in what ways do developers use Python 3 types? (ii) Which type errors do developers make? (iii) How do type errors from different tools compare? Surprisingly, when developers use static types, the code rarely type-checks with either of the tools. {MyPy} and {PyType} exhibit false positives, due to their static nature, but also flag many useful errors in our corpus. Lastly, {MyPy} and {PyType} embody two distinct type systems, flagging different errors in many cases. Understanding the usage of Python types can help guide tool-builders and researchers. Understanding the performance of popular tools can help increase the adoption of static types and tools by practitioners, ultimately leading to more correct and more robust Python code.},
	eventtitle = {{SPLASH} '20: Conference on Systems, Programming, Languages, and Applications, Software for Humanity},
	pages = {57--70},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} International Symposium on Dynamic Languages},
	publisher = {{ACM}},
	author = {Rak-amnouykit, Ingkarat and {McCrevan}, Daniel and Milanova, Ana and Hirzel, Martin and Dolby, Julian},
	urldate = {2021-04-14},
	date = {2020-11-17},
	langid = {english},
	file = {Rak-amnouykit et al. - 2020 - Python 3 types in the wild a tale of two type sys.pdf:/Users/tony.f/Zotero/storage/ZI2WRAFC/Rak-amnouykit et al. - 2020 - Python 3 types in the wild a tale of two type sys.pdf:application/pdf},
}

@inproceedings{storey_theories_2005,
	location = {St. Louis, {MO}, {USA}},
	title = {Theories, methods and tools in program comprehension: past, present and future},
	isbn = {978-0-7695-2254-8},
	url = {https://ieeexplore.ieee.org/document/1421034/},
	doi = {10.1109/WPC.2005.38},
	shorttitle = {Theories, methods and tools in program comprehension},
	abstract = {Program comprehension research can be characterized by both the theories that provide rich explanations about how programmers comprehend software, as well as the tools that are used to assist in comprehension tasks. During this talk I will review some of the key cognitive theories of program comprehension that have emerged over the past thirty years. Using these theories as a canvas, I will then explore how tools that are popular today have evolved to support program comprehension. Specifically, I will discuss how the theories and tools are related and reflect on the research methods that were used to construct the theories and evaluate the tools. The reviewed theories and tools will be further differentiated according to human characteristics, program characteristics, and the context for the various comprehension tasks. Finally, I will predict how these characteristics will change in the future and speculate on how a number of important research directions could lead to improvements in program comprehension tools and methods.},
	eventtitle = {Proceedings. 13th International Workshop on Program Comprehension},
	pages = {181--191},
	booktitle = {13th International Workshop on Program Comprehension ({IWPC}'05)},
	publisher = {{IEEE}},
	author = {Storey, M.-A.},
	urldate = {2021-03-25},
	date = {2005},
	langid = {english},
	file = {Storey - 2005 - Theories, methods and tools in program comprehensi.pdf:/Users/tony.f/Zotero/storage/7EF3DXWX/Storey - 2005 - Theories, methods and tools in program comprehensi.pdf:application/pdf},
}

@inproceedings{gordon_tutorial_1994,
	title = {A Tutorial on Co-induction and Functional Programming},
	abstract = {Co-induction is an important tool for reasoning about unbounded structures. This tutorial explains the foundations of co-induction, and shows how it justifies intuitive arguments about lazy streams, of central importance to lazy functional programmers. We explain from first principles a theory based on a new formulation of bisimilarity for functional programs, which coincides exactly with Morris-style contextual equivalence. We show how to prove properties of lazy streams by co-induction and derive Bird and Wadler's Take Lemma, a well-known proof technique for lazy streams.},
	pages = {78--95},
	booktitle = {In Glasgow Functional Programming Workshop},
	publisher = {Springer},
	author = {Gordon, Andrew D.},
	date = {1994},
	file = {Citeseer - Full Text PDF:/Users/tony.f/Zotero/storage/V237V4C9/Gordon - 1994 - A Tutorial on Co-induction and Functional Programm.pdf:application/pdf;Citeseer - Snapshot:/Users/tony.f/Zotero/storage/T9E59I6E/summary.html:text/html},
}

@article{crichton_role_2021,
	title = {The Role of Working Memory in Program Tracing},
	url = {http://arxiv.org/abs/2101.06305},
	doi = {10.1145/3411764.3445257},
	abstract = {Program tracing, or mentally simulating a program on concrete inputs, is an important part of general program comprehension. Programs involve many kinds of virtual state that must be held in memory, such as variable/value pairs and a call stack. In this work, we examine the influence of short-term working memory ({WM}) on a person's ability to remember program state during tracing. We first confirm that previous findings in cognitive psychology transfer to the programming domain: people can keep about 7 variable/value pairs in {WM}, and people will accidentally swap associations between variables due to {WM} load. We use a restricted focus viewing interface to further analyze the strategies people use to trace through programs, and the relationship of tracing strategy to {WM}. Given a straight-line program, we find half of our participants traced a program from the top-down line-by-line (linearly), and the other half start at the bottom and trace upward based on data dependencies (on-demand). Participants with an on-demand strategy made more {WM} errors while tracing straight-line code than with a linear strategy, but the two strategies contained an equal number of {WM} errors when tracing code with functions. We conclude with the implications of these findings for the design of programming tools: first, programs should be analyzed to identify and refactor human-memory-intensive sections of code. Second, programming environments should interactively visualize variable metadata to reduce {WM} load in accordance with a person's tracing strategy. Third, tools for program comprehension should enable externalizing program state while tracing.},
	journaltitle = {{arXiv}:2101.06305 [cs]},
	author = {Crichton, Will and Agrawala, Maneesh and Hanrahan, Pat},
	urldate = {2021-01-20},
	date = {2021-01-15},
	eprinttype = {arxiv},
	eprint = {2101.06305},
	keywords = {Computer Science - Human-Computer Interaction},
	file = {arXiv Fulltext PDF:/Users/tony.f/Zotero/storage/X68EQS9A/Crichton et al. - 2021 - The Role of Working Memory in Program Tracing.pdf:application/pdf;arXiv.org Snapshot:/Users/tony.f/Zotero/storage/W4XUTN47/2101.html:text/html},
}

@article{graham_hutton_its_2021,
	title = {It’s Easy As 1,2,3},
	url = {http://www.cs.nott.ac.uk/~pszgmh/123.pdf},
	abstract = {For more than twenty years now we have been using the language of integers and addition as a minimal setting in which to explore different aspects of programming language semantics. However, this language has never been the subject of an article in its own right. This article fills this gap, by showing how a range of semantic ideas can be presented in a simple manner through the lens of integers and addition. In this setting, it’s easy as 1,2,3.},
	pages = {18--33},
	journaltitle = {Functional Programming},
	author = {{Graham Hutton}},
	urldate = {2021-01-05},
	date = {2021-01-04},
	file = {It’s Easy As 1,2,3:/Users/tony.f/Zotero/storage/CQ5QN2KE/It’s Easy As 1,2,3.pdf:application/pdf},
}

@article{sulzmann_understanding_2007,
	title = {Understanding functional dependencies via constraint handling rules},
	volume = {17},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796806006137/type/journal_article},
	doi = {10.1017/S0956796806006137},
	abstract = {Functional dependencies are a popular and useful extension to Haskell style type classes. We give a reformulation of functional dependencies in terms of Constraint Handling Rules ({CHRs}). In previous work, {CHRs} have been employed for describing user-programmable type extensions in the context of Haskell style type classes. Here, we make use of {CHRs} to provide for the ﬁrst time a concise result that under some suﬃcient conditions, functional dependencies allow for sound, complete and decidable type inference. The suﬃcient conditions imposed on functional dependencies can be very limiting. We show how to safely relax these conditions and suggest several sound extensions of functional dependencies. Our results allow for a better understanding of functional dependencies and open up the opportunity for new applications.},
	pages = {83--129},
	number = {1},
	journaltitle = {Journal of Functional Programming},
	shortjournal = {J. Funct. Prog.},
	author = {Sulzmann, Martin and Duck, Gregory J. and Peyton-Jones, Simon and Stuckey, Peter J.},
	urldate = {2021-01-04},
	date = {2007-01},
	langid = {english},
	file = {Sulzmann et al. - 2007 - Understanding functional dependencies via constrai.pdf:/Users/tony.f/Zotero/storage/G49PP4SL/Sulzmann et al. - 2007 - Understanding functional dependencies via constrai.pdf:application/pdf},
}

@inproceedings{stuckey_interactive_2003-1,
	location = {Uppsala, Sweden},
	title = {Interactive type debugging in Haskell},
	isbn = {978-1-58113-758-3},
	url = {http://portal.acm.org/citation.cfm?doid=871895.871903},
	doi = {10.1145/871895.871903},
	eventtitle = {the {ACM} {SIGPLAN} workshop},
	pages = {72--83},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} workshop on Haskell  - Haskell '03},
	publisher = {{ACM} Press},
	author = {Stuckey, Peter J. and Sulzmann, Martin and Wazny, Jeremy},
	urldate = {2021-01-04},
	date = {2003},
	langid = {english},
	file = {Stuckey et al. - 2003 - Interactive type debugging in Haskell.pdf:/Users/tony.f/Zotero/storage/WM8YMYEN/Stuckey et al. - 2003 - Interactive type debugging in Haskell.pdf:application/pdf},
}

@article{strachey_fundamental_nodate,
	title = {Fundamental Concepts in Programming Languages},
	abstract = {This paper forms the substance of a course of lectures given at the International Summer School in Computer Programming at Copenhagen in August, 1967. The lectures were originally given from notes and the paper was written after the course was ﬁnished. In spite of this, and only partly because of the shortage of time, the paper still retains many of the shortcomings of a lecture course. The chief of these are an uncertainty of aim—it is never quite clear what sort of audience there will be for such lectures—and an associated switching from formal to informal modes of presentation which may well be less acceptable in print than it is natural in the lecture room. For these (and other) faults, I apologise to the reader.},
	pages = {39},
	author = {Strachey, Christopher},
	langid = {english},
	file = {Strachey - Fundamental Concepts in Programming Languages.pdf:/Users/tony.f/Zotero/storage/DW9JBULE/Strachey - Fundamental Concepts in Programming Languages.pdf:application/pdf},
}

@inproceedings{neubauer_discriminative_2003,
	location = {Uppsala, Sweden},
	title = {Discriminative sum types locate the source of type errors},
	isbn = {978-1-58113-756-9},
	url = {http://portal.acm.org/citation.cfm?doid=944705.944708},
	doi = {10.1145/944705.944708},
	abstract = {We propose a type system for locating the source of type errors in an applied lambda calculus with {ML}-style polymorphism. The system is based on discriminative sum types—known from work on soft typing—with annotation subtyping and recursive types. This way, type clashes can be registered in the type for later reporting. The annotations track the potential producers and consumers for each value so that clashes can be traced to their cause.},
	eventtitle = {the eighth {ACM} {SIGPLAN} international conference},
	pages = {15--26},
	booktitle = {Proceedings of the eighth {ACM} {SIGPLAN} international conference on Functional programming  - {ICFP} '03},
	publisher = {{ACM} Press},
	author = {Neubauer, Matthias and Thiemann, Peter},
	urldate = {2021-01-04},
	date = {2003},
	langid = {english},
	file = {Neubauer and Thiemann - 2003 - Discriminative sum types locate the source of type.pdf:/Users/tony.f/Zotero/storage/IZBFRG5S/Neubauer and Thiemann - 2003 - Discriminative sum types locate the source of type.pdf:application/pdf},
}

@article{lamraoui_formula-based_2016,
	title = {A Formula-based Approach for Automatic Fault Localization of Multi-fault Programs},
	volume = {24},
	issn = {1882-6652},
	url = {https://www.jstage.jst.go.jp/article/ipsjjip/24/1/24_88/_article},
	doi = {10.2197/ipsjjip.24.88},
	abstract = {Formula-based fault localization approach is an algorithmic method that is able to provide ﬁne-grained information account for identiﬁed root causes. The method combines the {SAT}-based formal veriﬁcation techniques with the Reiter’s model-based diagnosis theory. This paper adapts the formula-based fault localization method, and introduces a new program encoding, called full ﬂow-sensitive trace formula. This encoding is particularly useful for programs with multiple faults. Furthermore, we improve the eﬃciency of computing the potential root causes by using the push \& pop mechanism of the Yices solver. We implemented the method in a tool, {SNIPER}, which was applied to some benchmarks. All single and multiple faults were successfully identiﬁed and discriminated.},
	pages = {88--98},
	number = {1},
	journaltitle = {Journal of Information Processing},
	shortjournal = {Journal of Information Processing},
	author = {Lamraoui, Si-Mohamed and Nakajima, Shin},
	urldate = {2023-05-15},
	date = {2016},
	langid = {english},
	file = {Lamraoui and Nakajima - 2016 - A Formula-based Approach for Automatic Fault Local.pdf:/Users/tony.f/Zotero/storage/W9TN92SW/Lamraoui and Nakajima - 2016 - A Formula-based Approach for Automatic Fault Local.pdf:application/pdf},
}

@misc{bekkouche_exploration_2015,
	title = {Exploration of the scalability of {LocFaults} approach for error localization with While-loops programs},
	url = {http://arxiv.org/abs/1503.05508},
	abstract = {A model checker can produce a trace of counterexample, for an erroneous program, which is often long and diﬃcult to understand. In general, the part about the loops is the largest among the instructions in this trace. This makes the location of errors in loops critical, to analyze errors in the overall program. In this paper, we explore the scalability capabilities of {LocFaults}, our error localization approach exploiting paths of {CFG}(Control Flow Graph) from a counterexample to calculate the {MCDs} (Minimal Correction Deviations), and {MCSs} (Minimal Correction Subsets) from each found {MCD}. We present the times of our approach on programs with While-loops unfolded b times, and a number of deviated conditions ranging from 0 to n. Our preliminary results show that the times of our approach, constraint-based and ﬂow-driven, are better compared to {BugAssist} which is based on {SAT} and transforms the entire program to a Boolean formula, and further the information provided by {LocFaults} is more expressive for the user.},
	number = {{arXiv}:1503.05508},
	publisher = {{arXiv}},
	author = {Bekkouche, Mohammed},
	urldate = {2023-05-15},
	date = {2015-03-18},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {1503.05508 [cs]},
	keywords = {Computer Science - Artificial Intelligence, Computer Science - Software Engineering},
	file = {Bekkouche - 2015 - Exploration of the scalability of LocFaults approa.pdf:/Users/tony.f/Zotero/storage/YG6EIUVG/Bekkouche - 2015 - Exploration of the scalability of LocFaults approa.pdf:application/pdf},
}

@inproceedings{demoen_type_1999,
	location = {Auckland, New Zealand},
	title = {Type Constraint Solving for Parametric and Ad-hoc Polymorphism},
	abstract = {Uni cation has long been used as a mechanism for type checking and type inference for Hindley-Milner types in functional programming. The programmer de nes the possible types, and the compiler uses uni cation to check and infer types for function de nitions. In constraint logic programming it is natural to extend the functional programming case by allowing overloading of predicate and function de nitions, that is, ad-hoc polymorphism. Mycroft and O'Keefe showed how to check predicate type declarations under these assumptions. In this paper, we show how to infer predicate types, by translating a constraint logic program with given types into a logic program over types. The program can then be used to check and infer the possible types for the predicates and variables appearing in the original program.},
	eventtitle = {1999 22nd Australasian Computer Science Conference},
	booktitle = {1999 22nd Australasian Computer Science Conference},
	author = {Demoen, Bart and Banda, Maria and Stuckey, Peter},
	date = {1999-01},
	langid = {english},
	file = {Demoen - Type Constraint Solving for Parametric and Ad-hoc .pdf:/Users/tony.f/Zotero/storage/XWD8EE5G/Demoen - Type Constraint Solving for Parametric and Ad-hoc .pdf:application/pdf},
}

@misc{fu_chameleonide_2023,
	title = {{ChameleonIDE}: Untangling Type Errors Through Interactive Visualization and Exploration},
	url = {http://arxiv.org/abs/2303.09791},
	doi = {10.48550/arXiv.2303.09791},
	shorttitle = {{ChameleonIDE}},
	abstract = {Dynamically typed programming languages are popular in education and the software industry. While presenting a low barrier to entry, they suffer from run-time type errors and longer-term problems in code quality and maintainability. Statically typed languages, while showing strength in these aspects, lack in learnability and ease of use. In particular, fixing type errors poses challenges to both novice users and experts. Further, compiler-type error messages are presented in a static way that is biased toward the first occurrence of the error in the program code. To help users resolve such type errors, we introduce {ChameleonIDE}, a type debugging tool that presents type errors to the user in an unbiased way, allowing them to explore the full context of where the errors could occur. Programmers can interactively verify the steps of reasoning against their intention. Through three studies involving real programmers, we showed that {ChameleonIDE} is more effective in fixing type errors than traditional text-based error messages. This difference is more significant in harder tasks. Further, programmers actively using {ChameleonIDE}'s interactive features are shown to be more efficient in fixing type errors than passively reading the type error output.},
	number = {{arXiv}:2303.09791},
	publisher = {{arXiv}},
	author = {Fu, Shuai and Dwyer, Tim and Stuckey, Peter J. and Wain, Jackson and Linossier, Jesse},
	urldate = {2023-05-16},
	date = {2023-03-17},
	eprinttype = {arxiv},
	eprint = {2303.09791 [cs]},
	keywords = {Computer Science - Human-Computer Interaction, Computer Science - Programming Languages},
	file = {arXiv Fulltext PDF:/Users/tony.f/Zotero/storage/HMTR7KG5/Fu et al. - 2023 - ChameleonIDE Untangling Type Errors Through Inter.pdf:application/pdf;arXiv.org Snapshot:/Users/tony.f/Zotero/storage/44RGPKHD/2303.html:text/html},
}

@article{zhang_diagnosing_nodate,
	title = {Diagnosing Type Errors with Class},
	abstract = {Type inference engines often give terrible error messages, and the more sophisticated the type system the worse the problem. We show that even with the highly expressive type system implemented by the Glasgow Haskell Compiler ({GHC})—including type classes, {GADTs}, and type families—it is possible to identify the most likely source of the type error, rather than the ﬁrst source that the inference engine trips over. To determine which are the likely error sources, we apply a simple Bayesian model to a graph representation of the typing constraints; the satisﬁability or unsatisﬁability of paths within the graph provides evidence for or against possible explanations. While we build on prior work on error diagnosis for simpler type systems, inference in the richer type system of Haskell requires extending the graph with new nodes. The augmentation of the graph creates challenges both for Bayesian reasoning and for ensuring termination. Using a large corpus of Haskell programs, we show that this error localization technique is practical and signiﬁcantly improves accuracy over the state of the art.},
	author = {Zhang, Danfeng and Myers, Andrew C and Vytiniotis, Dimitrios and Peyton-Jones, Simon},
	langid = {english},
	file = {Zhang et al. - Diagnosing Type Errors with Class.pdf:/Users/tony.f/Zotero/storage/A9JTY3WJ/Zhang et al. - Diagnosing Type Errors with Class.pdf:application/pdf},
}

@article{zhang_sherrloc_2017,
	title = {{SHErrLoc}: A Static Holistic Error Locator},
	volume = {39},
	issn = {0164-0925, 1558-4593},
	url = {https://dl.acm.org/doi/10.1145/3121137},
	doi = {10.1145/3121137},
	shorttitle = {{SHErrLoc}},
	abstract = {We introduce a general way to locate programmer mistakes that are detected by static analyses. The program analysis is expressed in a general constraint language that is powerful enough to model type checking, information flow analysis, dataflow analysis, and points-to analysis. Mistakes in program analysis result in unsatisfiable constraints. Given an unsatisfiable system of constraints, both satisfiable and unsatisfiable constraints are analyzed to identify the program expressions most likely to be the cause of unsatisfiability. The likelihood of different error explanations is evaluated under the assumption that the programmer’s code is mostly correct, so the simplest explanations are chosen, following Bayesian principles. For analyses that rely on programmer-stated assumptions, the diagnosis also identifies assumptions likely to have been omitted. The new error diagnosis approach has been implemented as a tool called {SHErrLoc}, which is applied to three very different program analyses, such as type inference for a highly expressive type system implemented by the Glasgow Haskell Compiler—including type classes, Generalized Algebraic Data Types ({GADTs}), and type families. The effectiveness of the approach is evaluated using previously collected programs containing errors. The results show that when compared to existing compilers and other tools, {SHErrLoc} consistently identifies the location of programmer errors significantly more accurately, without any language-specific heuristics.},
	pages = {1--47},
	number = {4},
	journaltitle = {{ACM} Transactions on Programming Languages and Systems},
	shortjournal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Zhang, Danfeng and Myers, Andrew C. and Vytiniotis, Dimitrios and Peyton-Jones, Simon},
	urldate = {2023-05-24},
	date = {2017-12-31},
	langid = {english},
	file = {Zhang et al. - 2017 - SHErrLoc A Static Holistic Error Locator.pdf:/Users/tony.f/Zotero/storage/IUSL8EFY/Zhang et al. - 2017 - SHErrLoc A Static Holistic Error Locator.pdf:application/pdf},
}

@inproceedings{heeren_helium_2003,
	location = {Uppsala Sweden},
	title = {Helium, for learning Haskell},
	isbn = {978-1-58113-758-3},
	url = {https://dl.acm.org/doi/10.1145/871895.871902},
	doi = {10.1145/871895.871902},
	abstract = {Helium is a user-friendly compiler designed especially for learning the functional programming language Haskell. The quality of the error messages has been the main concern both in the choice of the language features and in the implementation of the compiler. Helium implements almost full Haskell, where the most notable difference is the absence of type classes. Our goal is to let students learn functional programming more quickly and with more fun. The compiler has been successfully employed in two introductory programming courses at Utrecht University.},
	eventtitle = {{HW}03: Haskell Workshop 2003 ( co-located with {ICFP} 2003 and {PPDP} 2003 Conferences)},
	pages = {62--71},
	booktitle = {Proceedings of the 2003 {ACM} {SIGPLAN} workshop on Haskell},
	publisher = {{ACM}},
	author = {Heeren, Bastiaan and Leijen, Daan and Van {IJzendoorn}, Arjan},
	urldate = {2023-05-24},
	date = {2003-08-28},
	langid = {english},
	file = {Heeren et al. - 2003 - Helium, for learning Haskell.pdf:/Users/tony.f/Zotero/storage/VITMGV8W/Heeren et al. - 2003 - Helium, for learning Haskell.pdf:application/pdf},
}

@article{liffiton_fast_2016,
	title = {Fast, flexible {MUS} enumeration},
	volume = {21},
	issn = {1383-7133, 1572-9354},
	url = {http://link.springer.com/10.1007/s10601-015-9183-0},
	doi = {10.1007/s10601-015-9183-0},
	abstract = {The problem of enumerating minimal unsatisﬁable subsets ({MUSes}) of an infeasible constraint system is challenging due ﬁrst to the complexity of computing even a single {MUS} and second to the potentially intractable number of {MUSes} an instance may contain. In the face of the latter issue, when complete enumeration is not feasible, a partial enumeration of {MUSes} can be valuable, ideally with a time cost for each {MUS} output no greater than that needed to extract a single {MUS}. Recently, two papers independently presented a new {MUS} enumeration algorithm well suited to partial {MUS} enumeration [21, 28]. The algorithm exhibits good anytime performance, steadily producing {MUSes} throughout its execution; it is constraint agnostic, applying equally well to any type of constraint system; and its ﬂexible structure allows it to incorporate advances in single {MUS} extraction algorithms and eases the creation of further improvements and modiﬁcations. This paper uniﬁes and expands upon the earlier work, presenting a detailed explanation of the algorithm’s operation in a framework that also enables clearer comparisons to previous approaches, and we present a new optimization of the algorithm as well. Expanded experimental results illustrate the algorithm’s improvement over past approaches and newly explore some of its variants.},
	pages = {223--250},
	number = {2},
	journaltitle = {Constraints},
	shortjournal = {Constraints},
	author = {Liffiton, Mark H. and Previti, Alessandro and Malik, Ammar and Marques-Silva, Joao},
	urldate = {2023-05-24},
	date = {2016-04},
	langid = {english},
	file = {Liffiton et al. - 2016 - Fast, flexible MUS enumeration.pdf:/Users/tony.f/Zotero/storage/K8GK3QPI/Liffiton et al. - 2016 - Fast, flexible MUS enumeration.pdf:application/pdf},
}

@article{ferdowsi_towards_2023,
	title = {Towards Human-Centered Types \& Type Debugging},
	url = {https://kilthub.cmu.edu/articles/conference_contribution/Towards_Human-Centered_Types_Type_Debugging/22227457/1},
	doi = {10.1184/R1/22227457.v1},
	abstract = {Advanced type systems, such as Rust’s Ownership, are gaining wider popularity among mainstream programming languages. And yet, despite users’ evident struggles with working with these systems, research on tools and techniques for improving the usability of types is rather scarce, and focused mostly on improving type error messages. In this paper, I hope to spark a discussion on human-centered tools and techniques for working with advanced type systems by surveying previous works and synthesizing them into a set of sketches for future research.},
	author = {Ferdowsi, Kasra},
	urldate = {2023-05-26},
	date = {2023-03-30},
	langid = {english},
	note = {Publisher: Plateau Workshop},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/HLZPTR7S/Ferdowsi - 2023 - Towards Human-Centered Types & Type Debugging.pdf:application/pdf},
}

@article{binkley_empirical_2007,
	title = {An empirical study of static program slice size},
	volume = {16},
	issn = {1049-331X, 1557-7392},
	url = {https://dl.acm.org/doi/10.1145/1217295.1217297},
	doi = {10.1145/1217295.1217297},
	abstract = {This article presents results from a study of all slices from 43 programs, ranging up to 136,000 lines of code in size. The study investigates the effect of five aspects that affect slice size. Three slicing algorithms are used to study two algorithmic aspects: calling-context treatment and slice granularity. The remaining three aspects affect the upstream dependencies considered by the slicer. These include collapsing structure fields, removal of dead code, and the influence of points-to analysis.
            The results show that for the most precise slicer, the average slice contains just under one-third of the program. Furthermore, ignoring calling context causes a 50\% increase in slice size, and while (coarse-grained) function-level slices are 33\% larger than corresponding statement-level slices, they may be useful predictors of the (finer-grained) statement-level slice size. Finally, upstream analyses have an order of magnitude less influence on slice size.},
	pages = {8},
	number = {2},
	journaltitle = {{ACM} Transactions on Software Engineering and Methodology},
	shortjournal = {{ACM} Trans. Softw. Eng. Methodol.},
	author = {Binkley, David and Gold, Nicolas and Harman, Mark},
	urldate = {2023-05-26},
	date = {2007-04},
	langid = {english},
	file = {Binkley et al. - 2007 - An empirical study of static program slice size.pdf:/Users/tony.f/Zotero/storage/C8WQ4G9Z/Binkley et al. - 2007 - An empirical study of static program slice size.pdf:application/pdf},
}

@inproceedings{chen_lets_2014,
	location = {Melbourne, Australia},
	title = {Let's hear both sides: On combining type-error reporting tools},
	isbn = {978-1-4799-4035-6},
	url = {http://ieeexplore.ieee.org/document/6883038/},
	doi = {10.1109/VLHCC.2014.6883038},
	shorttitle = {Let's hear both sides},
	abstract = {Producing precise and helpful type error messages has been a challenge for the implementations of functional programming languages for over 3 decades now. Many different approaches and methods have been tried to solve this thorny problem, but current type-error reporting tools still suffer from a lack of precision in many cases. Based on the rather obvious observation that different approaches work well in different situations, we have studied the question of whether a combination of tools that exploits their diversity can lead to improved accuracy. Speciﬁcally, we have studied Helium, a Haskell implementation particularly aimed at producing good type error messages, and Lazy Typing, an approach developed previously by us to address the premature-error-commitment problem in type checkers. By analyzing the respective strengths and weaknesses of the two approaches we were able to identify a strategy to combine both tools that could markedly improve the accuracy of reported errors. Speciﬁcally, we report an evaluation of 1069 unique illtyped programs out of a total of 11256 Haskell programs that reveals that this combination strategy enjoys a correctness rate of 79\%, which is an improvement of 22\%/17\% compared to using Lazy Typing/Helium alone. In addition to describing this particular case study, we will also report insights we gained into the combination of error-reporting tools in general.},
	eventtitle = {2014 {IEEE} Symposium on Visual Languages and Human-Centric Computing ({VL}/{HCC})},
	pages = {145--152},
	booktitle = {2014 {IEEE} Symposium on Visual Languages and Human-Centric Computing ({VL}/{HCC})},
	publisher = {{IEEE}},
	author = {Chen, Sheng and Erwig, Martin and Smeltzer, Karl},
	urldate = {2023-05-29},
	date = {2014-07},
	langid = {english},
	file = {Chen et al. - 2014 - Let's hear both sides On combining type-error rep.pdf:/Users/tony.f/Zotero/storage/4SE8U8L8/Chen et al. - 2014 - Let's hear both sides On combining type-error rep.pdf:application/pdf},
}

@online{noauthor_goanna-paper_nodate,
	title = {goanna-paper},
	url = {https://www.overleaf.com/project/645f68eefc3930e3b8123fcf},
	abstract = {An online {LaTeX} editor that’s easy to use. No installation, real-time collaboration, version control, hundreds of {LaTeX} templates, and more.},
	urldate = {2023-05-29},
	langid = {english},
	file = {Snapshot:/Users/tony.f/Zotero/storage/T9IJV26P/645f68eefc3930e3b8123fcf.html:text/html},
}

@inproceedings{zhao_parallelizing_2016,
	location = {San Jose, {CA}, {USA}},
	title = {Parallelizing Partial {MUS} Enumeration},
	isbn = {978-1-5090-4459-7},
	url = {http://ieeexplore.ieee.org/document/7814637/},
	doi = {10.1109/ICTAI.2016.0077},
	abstract = {The problem of enumerating minimal unsatisﬁable subsets of a constraint system ({MUSes}) is a natural candidate for parallelization: as an enumeration problem, it allows for concurrent solving of independent subproblems, and as a typically intractable problem w.r.t. completion (which parallelization cannot transcend), the speed or rate of output (which parallelization can improve) is often the most important performance characteristic. In this work, we explore the parallelization of partial {MUS} enumeration (aiming to enumerate some {MUSes} within given resource constraints) via two extensions to a recently-developed sequential algorithm – one employing an existing parallel {singleMUS} extraction algorithm, the other parallelizing the entire enumeration algorithm – and we discuss variants and implementation details as well. Results of experiments run with up to 16 cores show that the full parallelization of the entire enumeration algorithm scales well, reaching an average of 92\% of perfect scaling with 4 cores and 70\% at 16 cores. Evaluating variants and implementation details illuminates how those choices impact performance, including a potentially counterintuitive result that sharing results between threads to avoid duplicate work is not beneﬁcial in the general case.},
	eventtitle = {2016 {IEEE} 28th International Conference on Tools with Artificial Intelligence ({ICTAI})},
	pages = {464--471},
	booktitle = {2016 {IEEE} 28th International Conference on Tools with Artificial Intelligence ({ICTAI})},
	publisher = {{IEEE}},
	author = {Zhao, Wenting and Liffiton, Mark H.},
	urldate = {2023-05-29},
	date = {2016-11},
	langid = {english},
	file = {Zhao and Liffiton - 2016 - Parallelizing Partial MUS Enumeration.pdf:/Users/tony.f/Zotero/storage/CBZ23UKQ/Zhao and Liffiton - 2016 - Parallelizing Partial MUS Enumeration.pdf:application/pdf},
}

@inproceedings{bendik_must_2020,
	location = {Cham},
	title = {{MUST}: Minimal Unsatisfiable Subsets Enumeration Tool},
	isbn = {978-3-030-45190-5},
	doi = {10.1007/978-3-030-45190-5_8},
	series = {Lecture Notes in Computer Science},
	shorttitle = {{MUST}},
	abstract = {In many areas of computer science, we are given an unsatisfiable set of constraints with the goal to provide an insight into the unsatisfiability. One of common approaches is to identify minimal unsatisfiable subsets ({MUSes}) of the constraint set. The more {MUSes} are identified, the better insight is obtained. However, since there can be up to exponentially many {MUSes}, their complete enumeration might be intractable. Therefore, we focus on algorithms that enumerate {MUSes} online, i.e. one by one, and thus can find at least some {MUSes} even in the intractable cases. Since {MUSes} find applications in different constraint domains and new applications still arise, there have been proposed several domain agnostic algorithms. Such algorithms can be applied in any constraint domain and thus theoretically serve as ready-to-use solutions for all the emerging applications. However, there are almost no domain agnostic tools, i.e. tools that both implement domain agnostic algorithms and can be easily extended to support any constraint domain. In this work, we close this gap by introducing a domain agnostic tool called {MUST}. Our tool outperforms other existing domain agnostic tools and moreover, it is even competitive to fully domain specific solutions.},
	pages = {135--152},
	booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
	publisher = {Springer International Publishing},
	author = {Bendík, Jaroslav and Černá, Ivana},
	editor = {Biere, Armin and Parker, David},
	date = {2020},
	langid = {english},
	keywords = {Diagnosis, Infeasibility analysis, Minimal unsatisfiable subsets, {MUS}, Unsatisfiability analysis},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/6BXZAANU/Bendík and Černá - 2020 - MUST Minimal Unsatisfiable Subsets Enumeration To.pdf:application/pdf},
}

@article{previti_partial_2013,
	title = {Partial {MUS} Enumeration},
	volume = {27},
	rights = {Copyright (c) 2021 Proceedings of the {AAAI} Conference on Artificial Intelligence},
	issn = {2374-3468},
	url = {https://ojs.aaai.org/index.php/AAAI/article/view/8657},
	doi = {10.1609/aaai.v27i1.8657},
	abstract = {Minimal explanations of infeasibility find a wide range of uses. In the Boolean domain, these are referred to as Minimal Unsatisfiable Subsets ({MUSes}). In some settings, one needs to enumerate {MUSes} of a Boolean formula. Most often the goal is to enumerate all {MUSes}. In cases where this is computationally infeasible, an alternative is to enumerate some {MUSes}. This paper develops a novel approach for partial enumeration of {MUSes}, that complements existing alternatives. If the enumeration of all {MUSes} is viable, then existing alternatives represent the best option. However, for formulas where the enumeration of all {MUSes} is unrealistic, our approach provides a solution for enumerating some {MUSes} within a given time bound. The experimental results focus on formulas for which existing solutions are unable to enumerate {MUSes}, and shows that the new approach can in most cases enumerate a non-negligible number of {MUSes} within a given time bound.},
	pages = {818--825},
	number = {1},
	journaltitle = {Proceedings of the {AAAI} Conference on Artificial Intelligence},
	author = {Previti, Alessandro and Marques-Silva, Joao},
	urldate = {2023-05-29},
	date = {2013-06-30},
	langid = {english},
	note = {Number: 1},
	keywords = {{MUS} Enumeration},
	file = {Full Text PDF:/Users/tony.f/Zotero/storage/AY4Y7MA7/Previti and Marques-Silva - 2013 - Partial MUS Enumeration.pdf:application/pdf},
}

@online{goanna_team_goanna_nodate,
	title = {Goanna Type Debugger},
	url = {https://codeberg.org/goanna/goanna},
	abstract = {goanna},
	titleaddon = {Codeberg.org},
	author = {Goanna team},
	urldate = {2023-06-01},
	langid = {american},
}

@online{gamari_glasgow_nodate,
	title = {The Glasgow Haskell Compiler},
	url = {https://www.haskell.org/ghc/},
	author = {Gamari, Ben},
	urldate = {2023-06-01},
	file = {Home — The Glasgow Haskell Compiler:/Users/tony.f/Zotero/storage/PNXA46ZG/ghc.html:text/html},
}

@software{helium4haskell_haskell_2023,
	title = {Haskell Helium},
	rights = {{GPL}-3.0},
	url = {https://github.com/Helium4Haskell/helium},
	abstract = {The Helium compiler, Helium-as-a-library, and the texthint interpreter},
	publisher = {Helium4Haskell},
	author = {{Helium4Haskell}},
	urldate = {2023-06-01},
	date = {2023-05-16},
	note = {original-date: 2017-09-15T12:56:44Z},
}

@online{stack_exchange_inc_stack_nodate,
	title = {Stack Overflow},
	url = {https://stackoverflow.com/},
	abstract = {Stack Overflow is the largest, most trusted online community for developers to learn, share​ ​their programming ​knowledge, and build their careers.},
	titleaddon = {Stack Overflow},
	author = {{Stack Exchange Inc}},
	urldate = {2023-06-02},
	langid = {english},
	file = {Snapshot:/Users/tony.f/Zotero/storage/CRPRNRJW/stackoverflow.com.html:text/html},
}

@misc{bogner_type_2022,
	title = {To Type or Not to Type? A Systematic Comparison of the Software Quality of {JavaScript} and {TypeScript} Applications on {GitHub}},
	url = {http://arxiv.org/abs/2203.11115},
	shorttitle = {To Type or Not to Type?},
	abstract = {{JavaScript} ({JS}) is one of the most popular programming languages, and widely used for web apps and even backend development. Due to its dynamic nature, however, {JS} applications often have a reputation for poor software quality. As a type-safe superset of {JavaScript}, {TypeScript} ({TS}) offers features to address this. However, there is currently insufficient empirical evidence to broadly support the claim that {TS} apps exhibit better software quality than {JS} apps. We therefore conducted a repository mining study based on 604 {GitHub} projects (299 for {JS}, 305 for {TS}) with over 16M {LoC} and collected four facets of software quality: a) code quality (\# of code smells per {LoC}), b) code understandability (cognitive complexity per {LoC}), c) bug proneness (bug fix commit ratio), and d) bug resolution time (mean time a bug issue is open). For {TS}, we also collected how frequently the type-safety ignoring `any` type was used. The analysis indicates that {TS} apps exhibit significantly better code quality and understandability than {JS} apps. Contrary to expectations, however, bug proneness and bug resolution time of our {TS} sample were not significantly lower than for {JS}: mean bug fix commit ratio was more than 60\% larger (0.126 vs. 0.206), and {TS} projects needed on average more than an additional day to fix bugs (31.86 vs. 33.04 days). Furthermore, reducing the usage of the `any` type in {TS} apps was significantly correlated with all metrics except bug proneness (Spearman's rho between 0.17 and 0.26). Our results indicate that the perceived positive influence of {TypeScript} for avoiding bugs in comparison to {JavaScript} may be more complicated than assumed. While using {TS} seems to have benefits, it does not automatically lead to less and easier to fix bugs. However, more research is needed in this area, especially concerning the potential influence of project complexity and developer experience.},
	number = {{arXiv}:2203.11115},
	publisher = {{arXiv}},
	author = {Bogner, Justus and Merkel, Manuel},
	urldate = {2023-09-25},
	date = {2022-03-21},
	eprinttype = {arxiv},
	eprint = {2203.11115 [cs]},
	keywords = {Computer Science - Software Engineering},
	file = {arXiv.org Snapshot:/Users/tony.f/Zotero/storage/ELFC9GDC/2203.html:text/html;Full Text PDF:/Users/tony.f/Zotero/storage/47JQZDHP/Bogner and Merkel - 2022 - To Type or Not to Type A Systematic Comparison of.pdf:application/pdf},
}

@software{anonymous_goanna_2023,
	title = {Goanna Haskell Type Error Debugger},
	url = {https://goanna.fly.dev/},
	version = {1.0.0},
	author = {{Anonymous}},
	urldate = {2023-10-08},
	date = {2023-10},
	file = {Goanna:/Users/tony.f/Zotero/storage/39MB3ZI8/goanna.fly.dev.html:text/html},
}

@report{simon_marlow_haskell_2010,
	title = {Haskell 2010 Language Report},
	url = {https://www.haskell.org/definition/haskell2010.pdf},
	author = {{Simon Marlow}},
	urldate = {2023-10-08},
	date = {2010},
	file = {haskell2010.pdf:/Users/tony.f/Zotero/storage/X2FK7B8F/haskell2010.pdf:application/pdf},
}

@online{anonymous_goannas_2023,
	title = {Goanna's Haskell Language Coverage},
	url = {https://goanna.fly.dev/coverage.html},
	shorttitle = {Coverage},
	titleaddon = {Goanna's Haskell Language Coverage},
	author = {{Anonymous}},
	urldate = {2023-10-08},
	date = {2023-10},
}

@online{anonymous_goanna_2023-1,
	title = {Goanna Online Demo},
	url = {https://goanna.fly.dev/demo},
	shorttitle = {Demo},
	titleaddon = {Goanna Online Demo},
	author = {{Anonymous}},
	urldate = {2023-10-08},
	date = {2023-10},
}

@software{noauthor_haskell_2023,
	title = {Haskell Language Server},
	url = {https://github.com/haskell/haskell-language-server},
	abstract = {Official haskell ide support via language server ({LSP}). Successor of ghcide \& haskell-ide-engine.},
	version = {2.3.0.0},
	urldate = {2023-10-09},
	date = {2023},
	file = {haskell/haskell-language-server\: Official haskell ide support via language server (LSP). Successor of ghcide & haskell-ide-engine.:/Users/tony.f/Zotero/storage/DTRFQCYY/haskell-language-server.html:text/html},
}

@article{caprara_algorithms_nodate,
	title = {Algorithms for the Set Covering Problem},
	abstract = {The Set Covering Problem ({SCP}) is a main model for several important applications, including crew scheduling in railway and mass-transit companies. In this survey, we focus our attention on the most recent and e ective algorithms for {SCP}, considering both heuristic and exact approaches, outlining their main characteristics and presenting an experimental comparison on the test-bed instances of Beasley's {OR} Library.},
	author = {Caprara, Alberto and Fischetti, Matteo and Toth, Paolo},
	langid = {english},
	file = {Caprara et al. - Algorithms for the Set Covering Problem.pdf:/Users/tony.f/Zotero/storage/52H7TWM3/Caprara et al. - Algorithms for the Set Covering Problem.pdf:application/pdf},
}

@misc{cristia_combining_2023,
	title = {Combining Type Checking and Set Constraint Solving to Improve Automated Software Verification},
	url = {http://arxiv.org/abs/2205.01713},
	abstract = {In this paper we show how prescritive type checking and constraint solving can be combined to increase automation during software verification. We do so by defining a type system and implementing a typechecker for \{log\} (read ‘setlog’), a Constraint Logic Programming ({CLP}) language and satisfiability solver based on set theory. Hence, we proceed as follows: a) a type system for \{log\} is defined; b) the constraint solver is proved to be safe w.r.t. the type system; c) the implementation of a concrete typechecker is presented; d) the integration of type checking and set constraint solving to increase automation during software verification is discussed; and f) two industrial-strength case studies are presented where this combination is used with very good results.},
	number = {{arXiv}:2205.01713},
	publisher = {{arXiv}},
	author = {Cristiá, Maximiliano and Rossi, Gianfranco},
	urldate = {2023-10-10},
	date = {2023-10-06},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {2205.01713 [cs]},
	keywords = {Computer Science - Programming Languages, Computer Science - Logic in Computer Science},
	file = {Cristiá and Rossi - 2023 - Combining Type Checking and Set Constraint Solving.pdf:/Users/tony.f/Zotero/storage/IHQVRML8/Cristiá and Rossi - 2023 - Combining Type Checking and Set Constraint Solving.pdf:application/pdf},
}

@misc{cristia_combining_2023-1,
	title = {Combining Type Checking and Set Constraint Solving to Improve Automated Software Verification},
	url = {http://arxiv.org/abs/2205.01713},
	abstract = {In this paper we show how prescritive type checking and constraint solving can be combined to increase automation during software verification. We do so by defining a type system and implementing a typechecker for \{log\} (read ‘setlog’), a Constraint Logic Programming ({CLP}) language and satisfiability solver based on set theory. Hence, we proceed as follows: a) a type system for \{log\} is defined; b) the constraint solver is proved to be safe w.r.t. the type system; c) the implementation of a concrete typechecker is presented; d) the integration of type checking and set constraint solving to increase automation during software verification is discussed; and f) two industrial-strength case studies are presented where this combination is used with very good results.},
	number = {{arXiv}:2205.01713},
	publisher = {{arXiv}},
	author = {Cristiá, Maximiliano and Rossi, Gianfranco},
	urldate = {2023-10-10},
	date = {2023-10-06},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {2205.01713 [cs]},
	keywords = {Computer Science - Programming Languages, Computer Science - Logic in Computer Science},
	file = {Cristiá and Rossi - 2023 - Combining Type Checking and Set Constraint Solving.pdf:/Users/tony.f/Zotero/storage/HPMIHRWJ/Cristiá and Rossi - 2023 - Combining Type Checking and Set Constraint Solving.pdf:application/pdf},
}

@misc{zeng_identifying_2019,
	title = {Identifying Barriers to Adoption for Rust through Online Discourse},
	url = {http://arxiv.org/abs/1901.01001},
	abstract = {Rust is a low-level programming language known for its unique approach to memory-safe systems programming and for its steep learning curve. To understand what makes Rust difficult to adopt, we surveyed the top Reddit and Hacker News posts and comments about Rust; from these online discussions, we identified three hypotheses about Rust's barriers to adoption. We found that certain key features, idioms, and integration patterns were not easily accessible to new users.},
	number = {{arXiv}:1901.01001},
	publisher = {{arXiv}},
	author = {Zeng, Anna and Crichton, Will},
	urldate = {2023-10-12},
	date = {2019-01-04},
	eprinttype = {arxiv},
	eprint = {1901.01001 [cs]},
	keywords = {Computer Science - Human-Computer Interaction, Computer Science - Programming Languages},
	file = {arXiv.org Snapshot:/Users/tony.f/Zotero/storage/KQ6HNQDP/1901.html:text/html;Full Text PDF:/Users/tony.f/Zotero/storage/U2326BY4/Zeng and Crichton - 2019 - Identifying Barriers to Adoption for Rust through .pdf:application/pdf},
}

@article{chitil_compositional_nodate,
	title = {Compositional Explanation of Types and Algorithmic Debugging of Type Errors},
	abstract = {The type systems of most typed functional programming languages are based on the Hindley-Milner type system. A practical problem with these type systems is that it is often hard to understand why a program is not type correct or a function does not have the intended type. We suggest that at the core of this problem is the diﬃculty of explaining why a given expression has a certain type. The type system is not deﬁned compositionally. We propose to explain types using a variant of the Hindley-Milner type system that deﬁnes a compositional type explanation graph of principal typings. We describe how the programmer understands types by interactive navigation through the explanation graph. Furthermore, the explanation graph can be the foundation for algorithmic debugging of type errors, that is, semi-automatic localisation of the source of a type error without even having to understand the type inference steps. We implemented a prototype of a tool to explore the usefulness of the proposed methods.},
	author = {Chitil, Olaf},
	langid = {english},
	file = {Chitil - Compositional Explanation of Types and Algorithmic.pdf:/Users/tony.f/Zotero/storage/UWK4YUE2/Chitil - Compositional Explanation of Types and Algorithmic.pdf:application/pdf},
}

@online{fausak_2022_2022,
	title = {2022 State of Haskell Survey Results},
	url = {https://taylor.fausak.me/2022/11/18/haskell-survey-results/},
	abstract = {The sixth annual State of Haskell Survey closed this week. This post summarizes the results and makes the raw data available. You may be interested in similar posts from 2021, 2020, 2019, 2018, and...},
	titleaddon = {taylor.fausak.me},
	author = {Fausak, Taylor},
	urldate = {2023-10-12},
	date = {2022-11-18},
	langid = {english},
	file = {Snapshot:/Users/tony.f/Zotero/storage/QI8QFE7C/haskell-survey-results.html:text/html},
}

@software{google_developers_or-tools_nodate,
	title = {{OR}-Tools {\textbar} Google for Developers},
	url = {https://developers.google.com/optimization},
	abstract = {The {OR}-Tools suite provides operations research software libraries and {APIs} for constraint optimization, linear optimization, and flow and graph algorithms.},
	version = {v9.7},
	author = {{Google Developers}},
	urldate = {2023-10-12},
	file = {Snapshot:/Users/tony.f/Zotero/storage/DSJDT2DW/optimization.html:text/html},
}

@online{noauthor_defining_nodate,
	title = {Defining an Enum - The Rust Programming Language},
	url = {https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html},
	urldate = {2023-10-13},
	file = {Defining an Enum - The Rust Programming Language:/Users/tony.f/Zotero/storage/5S67MPYJ/ch06-01-defining-an-enum.html:text/html},
}

@online{noauthor_introduction_nodate,
	title = {An Introduction To Generics - The Go Programming Language},
	url = {https://go.dev/blog/intro-generics},
	abstract = {An introduction to generics in Go.},
	urldate = {2023-10-13},
	langid = {english},
	file = {Snapshot:/Users/tony.f/Zotero/storage/TNPYILUB/intro-generics.html:text/html},
}

@online{noauthor_documentation_nodate,
	title = {Documentation - Type Inference},
	url = {https://www.typescriptlang.org/docs/handbook/type-inference.html},
	abstract = {How code flow analysis works in {TypeScript}},
	urldate = {2023-10-13},
	langid = {english},
	file = {Snapshot:/Users/tony.f/Zotero/storage/CE5NQC9D/type-inference.html:text/html},
}

@online{noauthor_stack_nodate-1,
	title = {Stack Overflow Developer Survey 2023},
	url = {https://survey.stackoverflow.co/2023/?utm_source=social-share&utm_medium=social&utm_campaign=dev-survey-2023},
	abstract = {In May 2023 over 90,000 developers responded to our annual survey about how they learn and level up, which tools they're using, and which ones they want.},
	titleaddon = {Stack Overflow},
	urldate = {2023-10-13},
	langid = {english},
	file = {Snapshot:/Users/tony.f/Zotero/storage/X5857UJR/2023.html:text/html},
}

@article{djang_static_2000,
	title = {Static Type Inference for a First-Order Declarative Visual Programming Language with Inheritance},
	volume = {11},
	issn = {1045926X},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1045926X99901532},
	doi = {10.1006/jvlc.1999.0153},
	pages = {191--235},
	number = {2},
	journaltitle = {Journal of Visual Languages \& Computing},
	shortjournal = {Journal of Visual Languages \& Computing},
	author = {Djang, Rebecca Walpole and Burnett, Margaret M. and Chen, Roger D.},
	urldate = {2023-10-24},
	date = {2000-04},
	langid = {english},
	file = {Djang et al. - 2000 - Static Type Inference for a First-Order Declarativ.pdf:/Users/tony.f/Zotero/storage/D3K462V7/Djang et al. - 2000 - Static Type Inference for a First-Order Declarativ.pdf:application/pdf},
}

@inproceedings{almeida_rustviz_2022,
	location = {Roma, Italy},
	title = {{RustViz}: Interactively Visualizing Ownership and Borrowing},
	isbn = {978-1-66544-214-5},
	url = {https://ieeexplore.ieee.org/document/9833121/},
	doi = {10.1109/VL/HCC53370.2022.9833121},
	shorttitle = {{RustViz}},
	abstract = {Rust is an industrial systems programming language unique in achieving memory safety without the need for a garbage collector. Instead, Rust relies on a unique and sometimes subtle resource ownership and borrowing system. This system can make learning Rust a challenge, even for experienced programmers. Motivated by these challenges, we introduce {RustViz}, a tool that allows an instructor to generate custom interactive timelines depicting ownership and borrowing events alongside Rust code examples embedded within learning material. These visualizations makes visible the static events, and subsequent state changes, that a Rust programmer must otherwise track entirely mentally. We have used {RustViz} to build a week-long Rust unit in a large undergraduate programming languages course. We demonstrate that this learning material, and the {RustViz} visualizations in particular, were valuable to students and led to the development of an accurate mental model of the essentials of ownership and borrowing in Rust.},
	eventtitle = {2022 {IEEE} Symposium on Visual Languages and Human-Centric Computing ({VL}/{HCC})},
	pages = {1--10},
	booktitle = {2022 {IEEE} Symposium on Visual Languages and Human-Centric Computing ({VL}/{HCC})},
	publisher = {{IEEE}},
	author = {Almeida, Marcelo and Cole, Grant and Du, Ke and Luo, Gongming and Pan, Shulin and Pan, Yu and Qiu, Kai and Reddy, Vishnu and Zhang, Haochen and Zhu, Yingying and Omar, Cyrus},
	urldate = {2023-10-24},
	date = {2022-09-12},
	langid = {english},
	file = {Almeida et al. - 2022 - RustViz Interactively Visualizing Ownership and B.pdf:/Users/tony.f/Zotero/storage/IBZU6R3G/Almeida et al. - 2022 - RustViz Interactively Visualizing Ownership and B.pdf:application/pdf},
}

@article{kuchen_wflp04_nodate,
	title = {{WFLP}’04 13th International Workshop on Functional and (Constraint) Logic Programming},
	author = {Kuchen, Herbert},
	langid = {english},
	file = {Kuchen - WFLP’04 13th International Workshop on Functional .pdf:/Users/tony.f/Zotero/storage/JQ6AMC3M/Kuchen - WFLP’04 13th International Workshop on Functional .pdf:application/pdf},
}

@article{ruiz_tilc_2009,
	title = {{TILC}: The Interactive Lambda-Calculus Tracer},
	volume = {248},
	issn = {15710661},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1571066109002904},
	doi = {10.1016/j.entcs.2009.07.067},
	shorttitle = {{TILC}},
	abstract = {This paper introduces {TILC}: the interactive lambda-calculus tracer. {TILC} aims to be a friendly user graphical application that helps teaching/studying the main basic concepts of pure untyped lambda-calculus. This is achieved by allowing users to graphically interact with a sort of parse-tree of the lambda-terms and automatically reproducing these interactions in the lambda-term. This graphical interaction encourages students to practice with lambda-terms easing the learning of the syntax and of the operational semantics of lambda-calculus.},
	pages = {173--183},
	journaltitle = {Electronic Notes in Theoretical Computer Science},
	shortjournal = {Electronic Notes in Theoretical Computer Science},
	author = {Ruiz, David and Villaret, Mateu},
	urldate = {2023-10-24},
	date = {2009-08},
	langid = {english},
	file = {Ruiz and Villaret - 2009 - TILC The Interactive Lambda-Calculus Tracer.pdf:/Users/tony.f/Zotero/storage/XFLDRBXJ/Ruiz and Villaret - 2009 - TILC The Interactive Lambda-Calculus Tracer.pdf:application/pdf},
}

@article{clerici_graphical_nodate,
	title = {Graphical and Incremental Type Inference. A Graph Transformation Approach},
	author = {Clerici, Silvia and Zoltan, Cristina and Prestigiacomo, Guillermo},
	langid = {english},
	file = {Clerici et al. - Graphical and Incremental Type Inference. A Graph .pdf:/Users/tony.f/Zotero/storage/7AHTNR5M/Clerici et al. - Graphical and Incremental Type Inference. A Graph .pdf:application/pdf},
}

@inproceedings{yang_jun_how_2000,
	location = {Cozenza Italy},
	title = {How do people check polymorphic types?},
	url = {https://d1wqtxts1xzle7.cloudfront.net/30891349/10.1.1.33.8530-libre.pdf?1392112530=&response-content-disposition=inline%3B+filename%3DHow_do_people_check_polymorphic_types.pdf&Expires=1698125267&Signature=a6AetPT-R76sNymot-PHdIXuoMcFH7EKpZyEQ~a5cSE1tTGPU34Gn0-q7LfYyaJC9ZS3E6uSqy3n9ZzPxCVbnCLHW5nzRiOqow9i5g8JDnP6G-Ziu6r2hKduMZxIesXJMSSj8ej3392GSaFrpMA~7bd-wsSGIgeF0eE-nzfn92qu10RKkiGXaYhOUkZA0igwRG7oDWhooF1IGyxwC6iBGlVtXFD1sAOjbxsj44ewc886SM3L4ypBFzLbId4CyCwPdhS0VhygvCUHDdp1xjRsQmnZpPXlVGHAUdITzElnXB8pfXKRi7ois5TeKeFQlxDEU3-hyKy46fcXBNBfZE7X7A__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA},
	abstract = {Polymorphic typechecking algorithms efficiently locate type errors in programs, but users find error reporting from such algorithms hard to comprehend. We are investigating the development of a new polymorphic type checker that reports type errors in a more understandable form. Here we present the results of experiments into human checking of both correct and incorrect polymorphic typed programs, and briefly discuss their implications for our proposed new checker.},
	eventtitle = {12th Workshop of the Psychology of Programming Interest Group},
	booktitle = {12th Workshop of the Psychology of Programming Interest Group},
	author = {{Yang Jun} and {Greg Michaelson} and {Phil Trinder}},
	urldate = {2023-10-24},
	date = {2000-04},
	file = {10.1.1.33.8530-libre.pdf:/Users/tony.f/Zotero/storage/QIUSUAGZ/10.1.1.33.8530-libre.pdf:application/pdf},
}
